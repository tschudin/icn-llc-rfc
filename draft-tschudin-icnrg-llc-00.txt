



ICNRG Working Group                                          C. Tschudin
Internet-Draft                                       University of Basel
Intended status: Informational                                   C. Wood
Expires: March 12, 2016                                             PARC
                                                      September 09, 2015


                 Logical Link Control for ICN Protocols
                      draft-tschudin-icnrg-llc-00

Abstract

   This document describes an ICN logical link control (ICN-LLC)
   protocol to establish, configure, test, and negotiate options for
   links between point-to-point ICN-enabled endpoints.  ICN-LLC is
   analogous to PPP in that it provides the functionality of link
   control and network protocol configuration together.  However, it
   includes a mandatory step of securing a given link either through
   outer means (DTLS, IPsec, or MacSec) or through a native method
   inside this ICN-LLC framework.  Inside the secure association, a data
   pipe abstraction is provided for local control as well as ICN
   transfer traffic.  The ICN-LLC framework enables to manage the
   corresponding session and pipe properties.  For example, transfer
   pipes could be configured to offer reliable and ordered datagram
   delivery for CCNx or NDN traffic, or the session could execute a
   fragmentation protocol in order to increase the MTU of the pipes
   beyond the link-imposed limit.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on March 12, 2016.







Tschudin & Wood          Expires March 12, 2016                 [Page 1]

Internet-Draft                   ICN-LLC                  September 2015


Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Taking over when endpoints see "first light"  . . . . . .   3
     1.2.  Rudimentary RPC . . . . . . . . . . . . . . . . . . . . .   4
     1.3.  ICN-LLC services  . . . . . . . . . . . . . . . . . . . .   4
     1.4.  Scope of document . . . . . . . . . . . . . . . . . . . .   4
   2.  Definitions and Notation  . . . . . . . . . . . . . . . . . .   5
   3.  ICN-LLC Concepts  . . . . . . . . . . . . . . . . . . . . . .   5
     3.1.  Assumptions . . . . . . . . . . . . . . . . . . . . . . .   5
     3.2.  Cast  . . . . . . . . . . . . . . . . . . . . . . . . . .   7
     3.3.  API for Endpoint Clients  . . . . . . . . . . . . . . . .   8
     3.4.  Client work flow (for unsecured links)  . . . . . . . . .   8
     3.5.  Client work flow (for secured links)  . . . . . . . . . .   9
   4.  Link-level RPC and Logical Link Traffic . . . . . . . . . . .  10
     4.1.  RPC-request . . . . . . . . . . . . . . . . . . . . . . .  10
     4.2.  RPC-response  . . . . . . . . . . . . . . . . . . . . . .  11
     4.3.  Logical Link Traffic  . . . . . . . . . . . . . . . . . .  11
   5.  LLC Identities and Security . . . . . . . . . . . . . . . . .  11
   6.  LLC Protocol Mechanics  . . . . . . . . . . . . . . . . . . .  13
     6.1.  Link Creation . . . . . . . . . . . . . . . . . . . . . .  13
       6.1.1.  Session Initialization  . . . . . . . . . . . . . . .  13
       6.1.2.  Inspection (Get MTU)  . . . . . . . . . . . . . . . .  14
       6.1.3.  Secure Association Establishment (WITHOUT outer
               security context) . . . . . . . . . . . . . . . . . .  15
       6.1.4.  Secure Association Establishment (WITH outer security
               context)  . . . . . . . . . . . . . . . . . . . . . .  17
     6.2.  Link Negotiation  . . . . . . . . . . . . . . . . . . . .  17
       6.2.1.  Set MTU . . . . . . . . . . . . . . . . . . . . . . .  18
       6.2.2.  Configure Fragmentation Mode  . . . . . . . . . . . .  18
     6.3.  Link Maintenance  . . . . . . . . . . . . . . . . . . . .  19
       6.3.1.  Keep-Alive  . . . . . . . . . . . . . . . . . . . . .  19
       6.3.2.  Dissociation  . . . . . . . . . . . . . . . . . . . .  19



Tschudin & Wood          Expires March 12, 2016                 [Page 2]

Internet-Draft                   ICN-LLC                  September 2015


     6.4.  Protocol Configuration  . . . . . . . . . . . . . . . . .  19
       6.4.1.  Create Logical Link (= pipe)  . . . . . . . . . . . .  20
       6.4.2.  Destroy Logical Link (= pipe) . . . . . . . . . . . .  21
     6.5.  Fragmentation . . . . . . . . . . . . . . . . . . . . . .  21
       6.5.1.  Indexed fragmentation . . . . . . . . . . . . . . . .  21
       6.5.2.  Begin/End fragmentation . . . . . . . . . . . . . . .  22
   7.  Encoding of Non-control Traffic and RPC Parameters  . . . . .  22
     7.1.  Encoding of message type  . . . . . . . . . . . . . . . .  22
     7.2.  Encoding of a message's fields (list encoding)  . . . . .  22
     7.3.  Length of Identifier Fields . . . . . . . . . . . . . . .  23
     7.4.  Encoding Examples . . . . . . . . . . . . . . . . . . . .  24
     7.5.  Minimum MTU, Fragmentation of LLC Messages and Message
           Stuffing  . . . . . . . . . . . . . . . . . . . . . . . .  25
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  25
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  25
   10. RPC Verbs and Configuration Name Space  . . . . . . . . . . .  25
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  26

1.  Introduction

   This document specifies a logical link control (LLC) protocol to (1)
   establish a secure association between two endpoints running ICN
   software, (2) enable endpoints to control, test, and negotiate
   options for the secured link, and (3) transfer ICN protocol messages
   in across this link.  In this way, it is much like the PPP (CITE)
   protocol.  It consists of a mandatory secure association
   establishment procedure (if encryption is not provided by the outer
   link layer), a set of management and negotiation methods to explore,
   configure, and control the essential parameters for communication,
   permitting to switch from unsecured message exchange to encrypted and
   authenticated communications, and a demux mechanism for ICN protocol
   message transfer.  It supports the dynamic creation of logical links
   (pipes) on a per-protocol basis, permitting to use the link for
   multiple ICN protocols and protocol versions such as CCNx and NDN, in
   parallel.

1.1.  Taking over when endpoints see "first light"

   It is assumed that two endpoints executing the ICN-LLC protocol have
   already discovered each other and configured their lower-layer
   transport mechanism to enable bidirectional communication.  A single
   session is established over this link for end-to-end control.  This
   session is used to control, for example, the session's (and in
   consequence also the ICN protocols') MTU size.  If the underlying
   link is not secure, a secure association phase must follow where each
   endpoint is authenticated using either ephemeral or long-term trusted
   identities.  Within the secured session, logical channels called
   pipes are established both for control and for production traffic.



Tschudin & Wood          Expires March 12, 2016                 [Page 3]

Internet-Draft                   ICN-LLC                  September 2015


   The hierarchy of control in ICN-LLC is shown below.

  +------------------------+
  |   1 Link               |  bidirectional, potentially secured, given
  |  +------------------+  |
  |  |   1 Session      |  |  secure endpoint association, negotiated
  |  |  +------------+  |  |
  |  |  |   N Pipes  |  |  |  secure unidirectional logical links, on-demand
  |  |  +------------+  |  |
  |  +------------------+  |
  +------------------------+

                  Figure 1: Control hierarchy in the LLC.

1.2.  Rudimentary RPC

   All negotiations in ICN-LLC follow a Remote Procedure Call style
   (RPC) for two important reasons: It describes the sequence and
   structures the content of Interest/Content-style request/responses.
   Moreover, it provides a universal parameter marshalling method based
   on "symbolic expression", see the section "Encoding of a message's
   fields".

   The alternative to this RPC framework would have been to adopt link-
   local names for control messages inside some specific ICN
   architecture (CCNx 0.8x, NDN 2013, CCNx 1.0, etc.).  However, this
   requires that each endhost understand and use the same ICN type and
   its naming scheme.  Moreover, managing the link for non-ICN traffic
   purposes (e.g., setting the MTU size) should be done independently of
   the protocol that exchanges traffic across the link.

1.3.  ICN-LLC services

   The goal of the ICN-LLC is to let two parties to negotiate session
   and pipe properties and to transfer production traffic in encrypted
   and encapsulated datagrams.  For example, pipes could be configured
   to provide reliable and ordered datagram delivery, or endpoints could
   negotiate traffic control parameters on a per-session or per-pipe
   basis.  The design of ICN-LLC's RPC approach is extensible enough in
   order to support a variety of endpoint- and application-specific link
   management requirements.

1.4.  Scope of document

   The rest of this document introduces definitions and notation used in
   the description of the ICN-LLC protocol, outlines the relevant
   concepts and then provides a high-level description of the protocol




Tschudin & Wood          Expires March 12, 2016                 [Page 4]

Internet-Draft                   ICN-LLC                  September 2015


   (along with message content) as well as the encoding details of each
   message.  A full encoding example completes this document.

2.  Definitions and Notation

   The following terms are used:

   o  endpoint: A (session) endpoint which is capable of supporting at
      least one ICN protocol, for example an IP node reachable via UDP
      and running an NDN forwarder.

   o  link: A bidirectional datagram service between two endpoints
      (e.g., UDP, Ethernet).

   o  outer security context: the result of a security protocol executed
      before the start of ICN-LLC e.g., DTLS, IPsec or MacSec.

   o  session: A semi-permanent context in which (possibly encrypted)
      information is exchanged over a link between two endpoints.

   o  session manager: A control unit responsible for managing a session
      between two endpoints.

   o  pipe, or logical link: An isolated and ephemeral context managed
      by a session manager in which encrypted traffic is sent between
      two endpoints.

   o  secure association: A set of shared security information (e.g.,
      session keys) shared between two endpoints that is used for secure
      communication.

   o  Remote Procedure Call (RPC): an Interest/Content exchange where an
      Interest carries the name of a remote procedure to be called as
      well as its parameters while the returned Content carries a return
      code and a result data structure.

   o  RPC-request: A request to perform a remote action.

   o  RPC-response: The result of having executed an RPC-request.

3.  ICN-LLC Concepts

3.1.  Assumptions

   Logically, the ICN-LLC protocol is analogous to PPP in that it
   provides the functionality of link control and higher-level network
   protocol (e.g., NDN, CCNx) configuration together.  It is comprosed
   of the following procedures:



Tschudin & Wood          Expires March 12, 2016                 [Page 5]

Internet-Draft                   ICN-LLC                  September 2015


   o  Link Creation (session initialization, inspection, SA
      inititialization)

   o  Link Negotiation (get/set MTU and other options or features, such
      as fragmentation)

   o  Link Management (keep-alive, destroy session, and reset session)

   o  Protocol Configuration (create and destroy pipes or logical links)

   The ICN-LLC protocol makes the following assumptions:

   (1) The communication parameters necessary to communicate over a link
   are established before the protocol is executed.  This includes
   settings that, for example, enable bidirectional firewall traversal.

   (2) The underlying link protocol provides the most basic ability to
   frame/encapsulate and move an arbitrary (up to some maximum) sized
   payload from one endpoint to another.  We do not assume ordered or
   reliable datagram transfer.  Thus, the protocol is entirely
   transport-agnostic.

   (3) All ICN-LLC traffic must be protected using authenticated
   encryption.  Two cases are distinguished, as shown in the following
   protocol stack configurations:

                 client apps                        client apps
                      |                                  |
     +------------+---+--+              +------------+---+--+
     | ini | ctrl | xfer |  ^         ^ | ini | ctrl | xfer |
     | msg | msgs | msgs |  |         | | msg | msgs | msgs |
     |     |-------------|  |    L    | |     |-------------|
     |     |  LLC pipes  |  |    L    | |     |  LLC pipes  |
     |     |-------------|  |    C    | |     |-------------|
     |     | (fragment.) |  v         | |     | (fragment.) |
     +===================+            | |     |-------------|
     | outer security ctx|            v |     | auth, encr. |
     +-------------------+              +===================+
     | link: datagram srv|              | link: datagram srv|
     +-------------------+              +-------------------+

    3a) outer security context      3b) security part of ICN-LLC

   (3a) The underlying link comes enhanced with an "outer security
   context" i.e. it already provides security guarantees such that the
   peers are mutually authenticated and link datagrams are encrypted.
   In this case the ICN-LLC protocol reduces to handling the controll
   traffic and creating and tearing down pipes for ICN transfer traffic.



Tschudin & Wood          Expires March 12, 2016                 [Page 6]

Internet-Draft                   ICN-LLC                  September 2015


   (3b) If the link that underlies the ICN-LLC protocol is
   unauthenticated and unprotected, the ICN-LLC framework provides its
   own means to secure the communication.  Only thereafter it is
   possible to establish and manage ICN transfer pipes.

   In this case where ICN-LLC has to do the setup of a secure
   association, it is assumed that each endpoint has or can generate a
   cryptographic identity and can prove its identity to the other
   endpoints over the respective links.

   Moreover, endpoints have then to be pre-configured with one or more
   trust anchors permitting them to identity other endpoints that they
   trust i.e., those endpoints that are allowed to participate in the
   execution of the ICN-LLC protocol.  These identities could be
   ascertained online (making us of the trust anchors) or be pre-
   configured manually by system administrators.

   Note that in this case some intialization messages will be
   transported in clear until the secure association is established, or
   until a reset of the session is requested.

3.2.  Cast

   The ICN-LLC protocol entity exposes an API towards its clients, as is
   shown in the following diagram.

            +------+ +-----+                       +-----+ +------+
    clients | CCNx | | NDN |                       | NDN | | CCNx |
            +------+ +-----+                       +-----+ +------+
                ^       |                             ^        ^
                |       |                             |        |
                v       v                             |        v
            +------API-----+ +- Session ---------+ +-----API------+
            | ICN-LLC      | | <-- LLC (RPC) --> | | ICN-LLC      |
            |              | | <----- CCNx ----> | |              |
            | session      | | ------ NDN -----> | | session      |
            | manager      | |   ...             | | manager      |
            +--------------+ +-------------------+ +--------------+

            <-- endpoint --> <- (secured) link --> <-- endpoint -->

    Figure 2: Entities in ICN-LLC after secure association: all logical
           links of the session are encrypted and authenticated.








Tschudin & Wood          Expires March 12, 2016                 [Page 7]

Internet-Draft                   ICN-LLC                  September 2015


3.3.  API for Endpoint Clients

   The goal of the ICN-LLC protocol and its session manager is to expose
   an API that enables a run-time environment to connect local ICN
   software (clients, like for example a CCNx forwarder) to a remote
   peer by reusing the ICN-LLC's secured link.

   This client API provides access to very basic services to
   interconnect ICN peers.  In a UNIX environment, the API could be
   structured as follows (in C syntax):

     int icnllc_init(linkaddr *local, credentials *me, fct *notify);
     int icnllc_trustedInit(int secSock, fct *notify);
     int icnllc_register(int icnllcHandler, protoID *pid, fct *upcall);
     int icnllc_deregister(int registerNr);
     int icnllc_openSession(int handler, linkaddr *peer, trustanchors *t);
     int icnllc_openPipe(int sessionHandler, protoID *pid, fct *notify);
     int icnllc_write(int pipeHandler, char *msg, int len);
     int icnllc_read(int pipeHandler, char *buf, int nbyte);
     int icnllc_closePipe(int pipeHandler);
     int icnllc_closeSession(int sessionHandler)
     int icnllc_fini(int icnllcHandler);

   Wherever possible, ICN-LLC makes use of names rather than numbers to
   identify parameters and entities.  For example, protocol identifiers
   are drawn from a string-based name space (the string IS the
   identifier):

      typedef char* protoID;
      #define PROTOID_CCNX07  "/proto/icn/ccnx.2009"
      #define PROTOID_CCNX10  "/proto/icn/ccnx.2015"
      #define PROTOID_NDN     "/proto/icn/ndn.2013"

3.4.  Client work flow (for unsecured links)

   In case that the underlying link offers either raw and unsecured UDP,
   IP or Ethernet datagrams, ICN endnotes will use the API as follows.

   Scenario: A CCNx router wanting to establish a secure link to a peer:












Tschudin & Wood          Expires March 12, 2016                 [Page 8]

Internet-Draft                   ICN-LLC                  September 2015


   llc = icnllc_init(&myUDP, &myCredentials);
   s = icnllc_openSession(llc, &remoteUDP, &myTrustAnchor);

   peer = icnllc_openPipe(s, "/proto/icn/ccnx.2015", NULL);
   // ... encrypted and authenticated write and read:
   // icnllc_write(peer, data, datalen);
   // icnllc_read(peer, &buf, sizeof*buf);

   // parallel pipe for client-level remote mgmt actions (also secured):
   peerMgmt = icnllc_openPipe(s, "/proto/icn/ccnx.2015.mgmt");
   // ...
   icnllc_closePipe(peerMgmt);

   icnllc_closePipe(peer);
   icnllc_closeSession(s)
   icnllc_fini(llc);

   Scenario: A NDN router waiting for session establishment from other
   peers would issue this sequence of actions (without showing error
   handling):

      llc = icnllc_init(&myUDP, &myCredentials);
      ndn = icnllc_register(llc, "/proto/icn/ndn.2013", NDNupcall);
      // ... serve pipe establishment in NDNupcall()

      icnllc_deregister(ndn);
      icnllc_fini(llc);

3.5.  Client work flow (for secured links)

   If the underlying link is secured, the use of the API is simplified
   for the initiator side since no SA establishment must take place.

   Scenario: An endnode wanting to create logical pipes to two different
   remote NFD processes on the same host:

      llc = icnllc_trustedInit(securedSocket, &eventCallback);
      s = icnllc_openSession(llc, NULL, NULL);

      mgmt  = icnllc_openPipe(s, "/proto/icn/ndn.2015.mgmt");
      peer1 = icnllc_openPipe(s, "/proc/nfd/pid6225", NULL);
      peer2 = icnllc_openPipe(s, "/proc/nfd/pid6227", NULL);

      // read, write ...

      // close pipes ...
      icnllc_closeSession(s)
      icnllc_fini(llc);



Tschudin & Wood          Expires March 12, 2016                 [Page 9]

Internet-Draft                   ICN-LLC                  September 2015


   For the passive ("listening") side, the only change is from
   icnllc_init(PEERCOORDINATES, CREDENTIALS) to
   icnllc_trustedInit(SECURESOCK).

4.  Link-level RPC and Logical Link Traffic

   All configuration state of a session, including state related to the
   session's pipes, are managed by remote procedure operations.  To this
   end, two message types "RPC-request" and "RPC-response" are needed.
   A third message type serves to recognize actual production (= non-
   control) traffic, called "logical link traffic".  In the subsequent
   sections we describe these three message types and their fields, as
   well as the INC-LLC protocol, in an encoding-neutral way using
   prefixed lists.  For example, a packet with the fields

     +----------------------------+
     | f1 | f2 | more fields here |
     +----------------------------+

   will be represented as

     f1(f2, more fields here)

   That is, a parethesis pair is used as a notation for a list.  The
   empty list is either shown as () or NIL.

   We first show the data structures corresponding to the three message
   types before explaining each of them.

     rpc-request (RID, verb, parameter-list)
     rpc-response(RID, OK|FAIL, result-list|reason-list)
     llt-message (LID, blob)

     RID = (SID, nonce)         # request ID
     LID = (SID, PID, nonce)    # logical link ID
     SID = (intval1, intval2)   # session ID
     PID = (intval1, intval2)   # pipe ID

               Figure 3: The three message types of ICN-LLC.

4.1.  RPC-request

   (See also Figure [#llc-msgs]) An RPC-request message carries an ID
   that identifyies the request instance (RID) as well as a verb (= name
   of the remote procedure) and an optional payload with the list of
   parameters.





Tschudin & Wood          Expires March 12, 2016                [Page 10]

Internet-Draft                   ICN-LLC                  September 2015


   The RID carries two pieces of information: The current session's ID
   (SID) comes first, followed by a nonce.

   The role of the SID is to refer to previously established state and
   must be kept constant for all messages sent inside the established
   session.

   The Nonce is randomly chosen for each new RPC-request and permits to
   retransmit a request in case the sender thinks that the request or
   the reply got lost.  It is not a sequence number, though.

4.2.  RPC-response

   An RPC-response is always the reaction to a received RPC-request that
   was successfully parsed.  Requests with unknown session ID or verb
   MUST be silently discarded.

   The response contains a copy of the request's RID so that the
   requestor can correlate the answer with the pending request.
   Furthermore, the RPC-response has a verb similar to the RPC-request.
   However, the permitted verbs are limited to either "OK" or "FAIL".

4.3.  Logical Link Traffic

   Logical Link Traffic (LLT) refers to the messages that travel inside
   a pipe.  This message type has two fields: a logical link ID (LID)
   and a payload.

   The logical link is identified by a tuple that refers to the session
   context (SID) as well as the pipe ID to which this message belongs
   to.  In fact, the (SID, PID) tuple is a "network pointer" into the
   other end's function space [NetPtrs].  The pipe ID (PID) itself is
   also a tuple, in this case of two integers.  Often, pipes are used in
   pairs (for bidirectional interconnection of ICN clients) in which
   case the tuple's integer values are swapped.

   LLT messages whose LID cannot be matched with internal data
   structures MUST be silently discarded.

5.  LLC Identities and Security

   The concept of endpoint identity is crucial to the operation and
   execution of the LLC protocol.  Identities are used to authenticate
   endpoints so as to establish a secure (but possibly untrusted)
   association.  Cryptographically, an identity is associated with some
   keying material, e.g., a public and private key pair, or a pre-shared
   key.  In this document, we consider two types of identities:




Tschudin & Wood          Expires March 12, 2016                [Page 11]

Internet-Draft                   ICN-LLC                  September 2015


   1) [EPHEMERAL-IDENTITY] Ephemeral (short-term, on-demand) identities
   that are not certified by a trust anchor.  This type of identity
   could be backed by an ephemeral public and private key pair or a
   symmetric key, all of which are generated at random and used for the
   purposes of a single session.

   2) [TRUSTED-IDENTITY] Long-term identities that are backed by a trust
   anchor.  This type of identity could be represented as a certificate
   signed by a trusted Certification Authority (CA), or a pre-shared key
   that is was installed by a device manufacturer.

   Using these two types of identities, endpoints prove their identity
   using one of these identity types.  This ensures that, at a minimum,
   each endpoint is communicating with another endpoint which
   continually proves its identity by virtue of the fact that it uses
   the appropriate cryptographic keys for LLC message encryption.  Put
   another way, by minimally enforcing endpoint authentication using
   ephemeral identities, each endpoint is assured that they are always
   communicating with the endhost with whom the LLC session was
   initiated.

   Again, at a minimum, authentication based on ephemeral identities is
   mandatory.  Each endpoint may opt for strong authentication using a
   long-term identity.  For example, one endhost may use an ephemeral
   identity to authenticate itself with another endpoint using a long-
   term identity, or vice versa.  Alternatively, both endpoints may use
   long-term identities during authentication.  These combinatorial
   options are outlined below.

   1) Both endpoints authenticate themselves with ephemeral identities.
   This type of configuration may be suitable for two endpoints (i.e., a
   consumer device and forwarder) which are both within a common
   enterprise network.  2) One endpoint authenticates itself with an
   ephemeral identity, and the other authenticates itself with a long-
   term identity.  This type of configuration is appropriate in cases
   where an access point should only allow trusted clients to connect
   send traffic to the network.  In such a scenario, clients would
   possess long-term identities that are trusted by the access point,
   whereas the access point uses an ephemeral identity since consumers
   need not care about its trustworthiness.  3) Both endpoints
   authenticate themselves with long-term identities.  This type of
   configuration may be suitable for two core routers or forwarders in
   the public Internet.

   Note that supporting ephemeral identities for authentication enables
   traffic to flow freely through an endpoint.  This may be undesireable
   in some cases (i.e., for a router in the public Internet), but may be




Tschudin & Wood          Expires March 12, 2016                [Page 12]

Internet-Draft                   ICN-LLC                  September 2015


   acceptable for others (i.e., a forwarder within a trusted enterprise
   network).

6.  LLC Protocol Mechanics

   We now describe the procedures and tasks (RPC calls) that are used in
   the LLC protocol.  Any side can initiate a remote procedure call at
   any time.  It is suggested to limit the number of RPCs that one side
   issues in parallel to four (including nesting).

   For simplicity, we refer to each of the endpoints in the protocol as
   Q for Questioner and R for Responder.

   For notational purposes, Encrypt(K,M) stands for the ciphertext
   resulting from applying key K to message M and Signature(K,M) for a
   signature of M using key K.

   Note that the message exchange looks different depending on whether
   an outer security context exists or not.  If one exists, the RPC
   messages do not have to be encrypted; with an outer security context
   in place, the extra encryption activity must be ommited.  As an
   example:

   Q-->R: llt-message(LIDAB, Encrypt(keyAB,
                      rpc-request((SID, nonce), "noop", (NIL))))

   simply becomes

   Q-->R: llt-message(LIDAB, rpc-request((SID, nonce), "noop", (NIL)))

   In the following sections we always show the encryption case (where
   applicable).

6.1.  Link Creation

   Link creation is composed of session initialization, MTU discovery,
   and SA establishment.  All tasks following creation are related to
   negotiation and management, and will be described later.

6.1.1.  Session Initialization

   The session initialization task is the first step in establishing and
   using a link between two endpoints.  Assuming such a communication
   link for the underlying transport protocol is established, it is done
   by the following RPC exchange.






Tschudin & Wood          Expires March 12, 2016                [Page 13]

Internet-Draft                   ICN-LLC                  September 2015


   Q-->R: rpc-request((SID-1,0), nonce), CREATE-SESSION, ())

   On success:
     Q<--R: rpc-response((SID-1,0), nonce), OK, (SID-2))
   On failure:
     Q<--R: rpc-response((SID-1,0), nonce), FAIL, (<reason>))

            Figure 4: Session Initialization Message Exchange.

   After that exchange was executed, both ends will use the session ID
   consisting of SID-1 and SID-2 i.e., (SID-1, SID-2) in order to refer
   to this new session.  In the following we abbreviate this tuple to
   SID.

   Note that session initialization leaves the two endpoints in an
   unsecure state until they have executed the secure association task
   (see below).

   {Question: how to handle/mitigate an attacker injecting such "reset"
   messages?} {CAW: each side could store a hash preimage that is
   revealed during the SA step, but this induces state.  If these two
   operations are separated, then some state is necessary.}

6.1.2.  Inspection (Get MTU)

   Inspection messages may be used to recover generic information from
   an endpoint, e.g., the preferred MTU size.  The RPC exchange for an
   inspection message is as follows.

   Q-->R: rpc-request(SID, nonce), LOOKUP, ("/conf/preferredMTU"))

   On success:
     Q<--R: rpc-response((SID, nonce), OK, (<MTU value>))
   On failure:
     Q<--R: rpc-response((SID, nonce), FAIL, (<reason>))

                  Figure 5: Remote inspection (for MTU).

   Inspection messages may be used to query any well-named object from
   the recipient endpoint.  In the example above, the inspection for the
   preferred MTU would usually occur before establishing a secure
   session association (SA).  Thus, before SA, the contents of the RPC
   request and response are unencrypted.  However, after a SA is
   established, all inspection messages will be encrypted like other
   link traffic.






Tschudin & Wood          Expires March 12, 2016                [Page 14]

Internet-Draft                   ICN-LLC                  September 2015


6.1.3.  Secure Association Establishment (WITHOUT outer security
        context)

   If no outer security context exists, the secure association (SA)
   establishment message exchange is used to create a secure session
   over a given link.  This enables all subsequent traffic, including
   RPC exchanges, to be authenticated and encrypted.  If an outer
   security context already exists, this task must not be performed.

   The goal of SA establishment is for each endpoint to authenticate the
   entity running on the other endpoint of a given link, and to then
   establish shared symmetric keys to perform authenticated encryption
   of all traffic that follows the exchange.  Currently, we specify a
   simple challenge-response authentication protocol that enables mutual
   authentication with ephemeral identities.  This can be replaced with
   any functionally equivalent protocol.

   Note that authorization is distinctly separate from SA
   authentication, and is based on the set of trusted identities in
   possession by each endpoint.  For example, an endpoint will
   authenticate another endpoint requesting to establish a SA, but it
   will not authorize the endpoint unless the identity it used to
   authenticate itself is trusted by the receiver.  Therefore, it should
   be clear that authorization is not possible with ephemeral
   identities; authorization can only happen with long-term trusted
   identities.

   Also, observe that the SA involves nested RPCs: The responder to the
   initial RPC request will do an RPC in reverse direction in order to
   authenticate the requestor.

Q-->R: rpc-request((SID, nonceA), "prove-identity",
                   (NIL, <optionsA>, <keyshareA>,
                    NIL, <challengeA-1, challengeA-2>))

Q<--R: rpc-request((SID, nonceB), "prove-identity"
                   (nonceA, <optionsB>, <keyshareB>,
                    NIL, <challengeB-1, challengeB-2>))

Q-->R: rpc-response((SID, nonceB), OK,
                    (Signature(key-Q, challengeB-1),
                     Encrypt(keyAB, (PIDa, challengeB-2, nonceB, key-Q-ID)))

Q<--R: rpc-response((SID, nonceA), OK,
                    (Signature(key-R, challengeA-1),
                     Encrypt(keyAB, (PIDb, challengeA-2, nonceA, key-R-ID)))

     Figure 6: Secure Association with two challenge-response rounds.



Tschudin & Wood          Expires March 12, 2016                [Page 15]

Internet-Draft                   ICN-LLC                  September 2015


   In the first message, the value NIL is used to represent an empty
   nonce.

   The fields named optionsA and optionsB are key-value data structures
   that contain the following information, at a minimum:

   o  Preferred identity information (e.g., the form of signature
      algorithm to use when processing the challenge and response, list
      of available certificates or contained KeyIds, and the type of
      identity required by the endpoint - EPHEMERAL-IDENTITY or TRUSTED-
      IDENTITY).

   o  Diffie Hellman group parameters

   If R supports the Diffie Hellman group options provided by Q in
   optionsA, then those same values will be echoed back to Q in the
   optionsB structure.

   The key key-{Q,R} is a private key of {Q,R} or a symmetric key shared
   between Q and R.  The identifiers key-{Q,R}-ID are the corresponding
   key IDs of key-{Q,R}. Since the list of trusted certificates and
   KeyIds are provided in the initial "prove-identity" RPC request, the
   response must indicate which key was used to verify the signature.
   These identifiers can correspond to public keys or pre-shared keys:
   the only requirement is that, if TRUSTED-IDENTITY authentication is
   used, the recipient must be able to match the KeyId against their
   list of KeyIds.

   Lastly, keyAB is the key material derived from the output of the
   Diffie Hellman exchange with the shares keyshareA and keyshareB.
   That is, logically,

   keyAB = DH(keyshareA, keyshareB)

   When a failure occurs in the secure association RPC (not shown in the
   diagram above), the recipient replies with an error code (in clear)
   as in the Inspection message case and does not establish a new (or
   replace an old) secured logical link.

   Otherwise the secure association request succeeded and from this
   point in time on the two endpoints will exchange their control
   messages in encrypted form inside pipes.

   To this end, the protocol above exchanged and authenticated two
   endpoint-chosen numbers PIDa and PIDb.  The pipe starting from the
   side that chose the PIDa value, will use pipe ID PIDAB = (PIDa, PIDb)
   while the other side can use pipe identifier PIDBA = (PIDb,PIDa) to
   reply.  Subsequently we will refer to the respective logical link



Tschudin & Wood          Expires March 12, 2016                [Page 16]

Internet-Draft                   ICN-LLC                  September 2015


   identifiers that result from this as LIDAB=(SID,PIDAB,nonce) and
   LIDBA=(SID,PIDBA,nonce), where nonce is generated randomly per-
   message.

   For example, the remote inspection RPC can now be executed in a
   secured fashion as follows:

   Q-->R: llt-message(LIDAB, Encrypt(keyAB,
                      rpc-request((SID, nonce),
                                  "lookup", ("/conf/preferredMTU"))))
   On success:
   Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                      rpc-response((SID, nonce),
                                   OK, (<MTU value>))))

                    Figure 7: RPC inside a local pipe.

6.1.4.  Secure Association Establishment (WITH outer security context)

   If an outer security context exists, there is no need to perform an
   explicit (secure) association task because the Session Initialization
   already succeeded in associating both endpoints.

6.2.  Link Negotiation

   Note that negotiation tasks can only be performed once the endpoints
   are associated and have been authenticated and exchange their
   messages in encrypted form.  A request to change the MTU, for
   example, is invalid before session initialization.

   Negotiation tasks are performed imperatively: a questioner first
   selects the supported or provided values for a given option from the
   responder, and then subsequently sets the value of said option using
   one of the supported values.

   Failures can occur when a questioner fails to use or provide a
   correct value for the responder (i.e., an invalid MTU value is set,
   or an unsupported cryptographic algorithm is specified).  In all
   cases, when failures occur, the responder replies with a negative
   acknowledgement flag (FAIL) and lists the reason for the failure.
   The failure reason indicates only what option, command, or parameter
   was invalid, and does not provide details or possible remediation
   actions.








Tschudin & Wood          Expires March 12, 2016                [Page 17]

Internet-Draft                   ICN-LLC                  September 2015


6.2.1.  Set MTU

   Setting the MTU is a standard message in the LLC protocol that has
   the following RPC exchange format.  (We assume the default MTU was
   already acquired from the prior inquiry performed in the link
   creation step of the protocol.)

Q-->R: llt-message(LIDAB, Encrypt(keyAB,
                   rpc-request((SID, nonce), "set", ("/conf/MTU", <value>))))

On success:
  Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                     rpc-response((SID, nonce), OK, (<value>))))
On failure:
  Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                     rpc-response((SID, nonce), FAIL, (<reason>))))

                          Figure 8: Set the MTU.

6.2.2.  Configure Fragmentation Mode

   Fragmentation is a necessary part of a link protocol.  A questioner
   will lookup the supported fragmentation options and then subsequently
   ask to configure them, as shown below.

Q-->R: llt-message(LIDAB, Encrypt(keyAB,
                   rpc-request((SID, nonce), "get", ("/conf/frag"))))

Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                    rpc-response((SID, nonce), OK, (<frag-mode-list>, <frag-size-list>))))

                 Figure 9: Get the fragmentation options.

Q-->R: llt-message(LIDAB, Encrypt(keyAB,
                   rpc-request((SID, nonce), "set", ("/conf/frag", <frag-mode>, <frag-size>))))

On success:
  Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                     rpc-response((SID, nonce), OK, (<frag-mode>, <frag-size>))))
On failure:
  Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                     rpc-response((SID, nonce), FAIL, (<reason>))))

                 Figure 10: Set the fragmentation options.

   The responder must be carefull to not reply with a message length
   beyond the current MTU, in case fragmentation has not been activted
   yet.



Tschudin & Wood          Expires March 12, 2016                [Page 18]

Internet-Draft                   ICN-LLC                  September 2015


6.3.  Link Maintenance

   Link maintenance is composed of the tasks needed to detect failures,
   recover from failures or end an association.

   Currently,

   o  failure detection is done with periodic heartbeat or keep-alive
      messages sent from both endpoints for a specific link,

   o  there are no recovering methods defined, except starting from
      scratch with the link initialization phase.

   The dissociation task serves to tear down a session.

6.3.1.  Keep-Alive

   Use the NOOP call to verify that the peer session manager is still up
   and running.

   Q-->R: llt-message(LIDAB, Encrypt(KeyAB,
                      rpc-request((SID, nonce), NOOP, NIL)))

   Q<--R: llt-message(LIDBA, Encrypt(Key-AB,
                      rpc-response((SID, nonce), OK, NIL)))

6.3.2.  Dissociation

   Once a session is not needed anymore, it SHOULD be teared down.  In
   analogy to the teardown method for pipes, this is a unilateral action
   and always succeeds (even if no session was established beforehand).

   Q-->R: llt-message(LIDAB, Encrypt(KeyAB,
              rpc-request((SID, nonce), DESTROY-SESSION, (<reason>))))

   On success:
     Q<--R: llt-message(LIDBA, Encrypt(Key-AB,
                        rpc-response((SID, nonce), OK, NIL)))

6.4.  Protocol Configuration

   With a secured session established, and link features negotiated,
   both endpoints can then begin constructing and managing logical links
   (pipes) for ICN traffic.  We currently describe the mechanisms to
   create and destroy these links.  Other features can be added as
   needed using the same model.





Tschudin & Wood          Expires March 12, 2016                [Page 19]

Internet-Draft                   ICN-LLC                  September 2015


6.4.1.  Create Logical Link (= pipe)

   After a session and SA have been established, the protocol-specific
   links (pipe) must be created.  This is done with the following
   exchange.  The number 5 shown below is arbitrary and signals for this
   specific task that Q or R can choose their part of the pipe ID at
   will.

   Q-->R: llt-message(LIDAB, Encrypt(keyAB,
                      rpc-request((SID, nonce), "create-pipe",
                      (PID-5a, Key-5QR, <icn-protocol-identifier>))))
   On success:
     Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                        rpc-response((SID, nonce), OK, (PID-5b)))
   On failure:
     Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                        rpc-response((SID, nonce), FAIL, (<reason>))))

                 Figure 11: Logical Link (Pipe) Creation.

   This creates a new pipe whose identifier is the tuple (PID-5a, PID-
   5b).  That is, for messages send through this pipe, questioner Q will
   use the logical link ID LID5Q = (SID, (PID-5a, PID-5b)), whereas the
   responder R will use LID5R = (SID, (PID-5b, PID-5a)).

   Note that the messages will be encrypted by the symmetric key Key-5QR
   that was unilaterally chosen by the initiator of this RPC.  Since
   each pipe is owned and controlled by the session manager, it is
   sufficient for the session manager to simply derive and impose a new
   encryption key Key-5QR for the pipe during creation.  In other words,
   it is not necessary to perform another multi-round Diffie Hellman key
   exchange.

   The pipe creation needs a remote target, expressed in form of an
   client identifier "icn-protocol-identifier".  If the new pipe cannot
   be bound to such a client, the RPC may fail.  A partial list of
   failure reasons:

   o  "Protocol not supported"

   o  "Invalid key size"

   Currently, each pipe will use the same encryption algorithm and
   parameters for their respective traffic.  This could be changed by
   allowing endpoints to negotiate these parameters during the pipe
   creation exchange.





Tschudin & Wood          Expires March 12, 2016                [Page 20]

Internet-Draft                   ICN-LLC                  September 2015


6.4.2.  Destroy Logical Link (= pipe)

   Finally, when a pipe is finished, it must be destroyed and all state
   must be recycled.  This is done with the following exchange.

  Q-->R: llt-message(LIDAB, encrypt(KeyAB,
                     rpc-request((SID, nonce), "destroy-pipe", (PID-5)))

  Q<--R: llt-message(LIDBA, encrypt(Key-AB,
                     rpc-response((SID, nonce), OK, NIL)))

                Figure 12: Logical Link (Pipe) Destruction.

   After this exchange, both parties tear down and recycle their local
   state.  That is, both pipes (PID-5a,PID-5b) and (PID-5b,PID-5a) will
   be destroyed at the same time.  This destroy action request is
   idempotent; attempting to destroy a non-existent pipe will yield an
   OK response from the recipient.

   Note that the two pipes representing the logical control link, named
   (SID, PIDBA) and (SID, PIDAB) above, cannot be close.  Instead, the
   "destroy-session" RPC must be used.

6.5.  Fragmentation

   As a link protocol, ICN-LLC must support fragmentation to the link
   MTU size.  The used fragmentarion method is runtime-configurable and
   is subject to ICN-LLC's negotiation methodology.  Currently two (hop-
   by-hop) fragmentation schemas are envisaged: indexed fragmentation
   and Begin/End fragmentation.

6.5.1.  Indexed fragmentation

   In indexed fragmentation (without out-of-order delivery), all
   fragments for a given LLT or RPC message share a unique nonce.  In
   case of RPC messages, we reuse an RPC's nonce while LLT messages
   receive their own nonce.  In both cases, fragments carry an index
   number specifying the order in which the carried bytes must be
   reassembled to yield the original message, and the number of
   fragments needed for the original message.

   The fragments for LLC's three packet types look as follows:









Tschudin & Wood          Expires March 12, 2016                [Page 21]

Internet-Draft                   ICN-LLC                  September 2015


  RPC-request((SID, nonce) ...) -->
      RPC-request-frag((SID, nonce, ndx, cnt), part-of-orig-message)

  RPC-response((SID, nonce) ...) -->
      RPC-response-frag((SID, nonce, ndx, cnt), part-of-orig-message)

  llt-message((SID, PID, ...) -->
      llt-message-frag(SID, PID, frag-nonce, ndx, cnt, part-of-orig-msg)

   The receiver of a fragmented message will buffer each fragment until
   all have been received.  The size of this buffer is denoted by the
   fragment count in the LID and RID identifiers.  The original message
   is reassembled upon receipt of all fragments and then delivered to
   the appropriate handler.

   Also, each fragmented message buffer at the receiver is associated
   with a timer that is refreshed upon the receipt of a fragment.  If
   this timer expires, the buffer is cleared and the partially received
   message is dropped.

6.5.2.  Begin/End fragmentation

   to be written ...

7.  Encoding of Non-control Traffic and RPC Parameters

   Structurally, all three message types of ICN-LLC are identical in
   being a list of fields.  A single header byte discriminates among the
   message types, followed by an encoding of the message's field list:

        Byte 0    Bytes 1 to N-1
     +---------+--------------//--+
     | msgtype | listEncoding ....|
     +---------+--------------//--+

7.1.  Encoding of message type

   The assigned values for the one-byte-header are:

     0x81  llt-message
     0x82  rpc-request
     0x83  rpc-response

7.2.  Encoding of a message's fields (list encoding)

   ICN-LLC encodes lists in a similar way as was proposed by Rivest for
   symbolic expressions [SEXPR].  The variation consists in combining
   the "list bit" with a variable length field and in omitting the 0x00



Tschudin & Wood          Expires March 12, 2016                [Page 22]

Internet-Draft                   ICN-LLC                  September 2015


   byte to signal the end-of-list (because the length field already
   encodes this information).

   In ICN-LLC, a data structure is represented as a two-tuple of
   type+length and the content bytes: (TL, value).  The length tells the
   amount of bytes needed to represent the value.

   A data structure either is a list or an atom.  The general format for
   a list is:

     <list-bit=1, len-in-bytes> <element-1> ... <element-N>

   where an element can be either another list or an atom.

   The format for an atom is:

     <list-bit=0, len-in-bytes> <blob>

   Two atom types are defined (but the type is not made explicit in the
   ICN-LLC encoding): Strings are encoded without trailing zero, integer
   values are signed and are encoded in network order format.

   The type+len information is encoded with a varying number of bytes
   depending on the value of len.  In the following diagram, "L" stands
   for the list-bit and "l" for a bit of the length value to be encoded
   (unsigned, network order).

     len value      encoding (bits)

     0 .. 63        L0ll llll
     64 .. 8191     L10l llll  llll llll
     8192..1048575  L110 llll  llll llll  llll llll
     reserved       L111 ...

7.3.  Length of Identifier Fields

   Although fields can vary in length and therefore, for example, a
   pipeID could consist of two 8-bit values, it is recommended to
   implement identifiers according to the following MINIMAL lengths:

     4 Bytes    nonce
     2x2 Bytes  session ID
     2x2 Bytes  pipe ID








Tschudin & Wood          Expires March 12, 2016                [Page 23]

Internet-Draft                   ICN-LLC                  September 2015


7.4.  Encoding Examples

   a) LLT message

     llt-message(((0x1234,0x5678)(0x1111,0x2222))"abc") --> 21 Bytes

     0x81                     % msg type
     0x93                     % 0x80 + total length
       0x8e                   % LID
         0x86                 % SID
           0x02 0x12 0x34
           0x02 0x56 0x78
         0x86                 % PID
           0x02 0x11 0x11
           0x02 0x11 0x11
       0x03 0x61 0x62 0x63    % payload

   b) RPC-request (start session)

     rpc-request(((0x1234,0)0x73683559)"_rst"()) --> 19 Bytes

     0x82                     % msg type
     0x91                     % 0x80 + total length
       0x8a                   % RID
         0x84                 % SID
           0x02 0x12 0x34
           0x00
         0x04                 % nonce
           0x73 0x68 0x35 0x59
       0x04                   % verb
         0x5f 0x72 0x73 0x74
       0x80                   % empty param list

   c) RPC-response (session ack)

     rpc-response(((0x1234,0x5678)0x73683559)0x00()) --> 17 Bytes

     0x83                     % msg type
     0x8f                     % 0x80 + total length
       0x8c                   % RID
         0x84                 % SID
           0x02 0x12 0x34
           0x02 0x56 0x78
         0x04                 % nonce
           0x73 0x68 0x35 0x59
       0x01 0x00              % OK
       0x80                   % empty param list




Tschudin & Wood          Expires March 12, 2016                [Page 24]

Internet-Draft                   ICN-LLC                  September 2015


7.5.  Minimum MTU, Fragmentation of LLC Messages and Message Stuffing

   None of the three message types (LLT-message, RPC-request, RPC-
   response) may be fragmented.

   However, using RPC and being subject to negotiation, peers might use
   RPC to transfer parts of a larger message for remote assembly and
   then trigger the delivery of that remote memory block.

   The minimum (link-level) MTU is 1280 bytes.

   Multiple LLC messages can be combined into one frame as long as they
   fully fit into the link's MTU.

8.  Security Considerations

   yes

9.  References

   o  S-expressions http://people.csail.mit.edu/rivest/Sexp.txt

   o  Network pointers
      http://conferences.sigcomm.org/hotnets/2002/papers/tschudin.ps

10.  RPC Verbs and Configuration Name Space

   Verbs:

  OK               byte 0x00
  FAIL             byte 0x01
  CREATE-SESSION   "_ini"    , or "HELO", or "/builtin/create-session" or ....
  END-SESSION      "_fin"
  LOOKUP           "_get"
  CONFIGURE        "_set"
  NOOP             "_nop"
  PROVE-IDENTITY   "_prv"
  CREATE-PIPE      "_pii"
  DESTROY-PIPE     "_pif"

   Constants and "state registers" (MIB):

     /proto/icn/....

     /conf/rw/icnllc-version
     /conf/ro/preferredMTU
     /conf/rw/MTU




Tschudin & Wood          Expires March 12, 2016                [Page 25]

Internet-Draft                   ICN-LLC                  September 2015


Authors' Addresses

   Christian Tschudin
   University of Basel

   Email: christian.tschudin@unibas.ch


   Christopher A. Wood
   PARC

   Email: cwood@parc.com







































Tschudin & Wood          Expires March 12, 2016                [Page 26]
