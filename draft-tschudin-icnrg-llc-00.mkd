---
title: Logical Link Control for ICN Protocols
abbrev: ICN-LLC
docname: draft-tschudin-icnrg-llc-00
date: 2015-08-27
category: info

ipr: trust200902
area: General
workgroup: ICNRG Working Group
keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: C. Tschudin
    name: Christian Tschudin
    organization: University of Basel
    email: christian.tschudin@unibas.ch
 -
    ins: C. A. Wood
    name: Christopher A. Wood
    org: PARC
    email: cwood@parc.com

normative:
  RFC2119:
  RFC3986:
  RFC4086:
  RFC4648:

informative:
  RFC5389:
  I-D.ietf-behave-turn:
  STUNT:
    target: http://deusty.blogspot.com/2007/09/stunt-out-of-band-channels.html
    title: STUNT & out-of-band channels
    author:
      name: Robbie Hanson
      ins: R. Hanson
    date: 2007-09-17
  I-D.meyer-xmpp-e2e-encryption:
  I-D.ietf-xmpp-3920bis:



--- abstract

abc

--- middle

Introduction        {#problems}
============

This document specifies a logical link control (LLC) protocol to facilitate interoperability
and coexistence of ICN protocols such as CCNx and NDN. The goal of the LLC protocol
is to perform link negotiation between two endpoints to name, configure, and manage
the essential parameters for communication. This negotiation process is used to
establish a secure link between two endpoints through which all traffic is (or
can be) encrypted and authenticated.

The LLC negotiates the parameters for and manages a logical link between two endpoints.
It is assumed that two endpoints executing the LLC have already discovered each other
and configured their lower-layer transport mechanism to enable end-to-end communication.
A single session is establish over this link for end-to-end control. This session is
used to control, for example, the link MTU size before an encrypted channel has been
setup between the two endpoints. Within this session, an encrypted control channel is
established for further control messages; each endpoint is authenticated during this
stage.

Finally, after an encrypted control channel is established, per-protocol communication
channels, or threads, can be instantiated within the context of the link session.
A session manager is responsible for handling the control messages exchanged between
endpoints in the context of a given session. These individual threads are used to send
protocol-specific traffic between the two endpoints. For example, two endpoints with an established
session could create two separate threads for CCNx and NDN traffic.

The hierarchy of control in the LLC is shown below.

~~~
+-------------------------------------+
|                Link                 |
|  +-------------------------------+  |
|  |            Session            |  |
|  |   +------------------------+  |  |
|  |   |         Thread         |  |  |
|  |   +------------------------+  |  |
|  +-------------------------------+  |
+-------------------------------------+
~~~
{: #llc-hierarchy title="Control hierarchy in the LLC."}

All control (e.g., negotiation) messages follow RPC-style model. That is, a RPC-request
has an identity for the parent context (e.g., the session), an action (verb) that identifies
the action to be done, and additional parameters. Each RPC-request is followed by
an RPC-response which specifies the result of the operation, e.g., an OK flag
or a FAIL flag with some useful error information. All protocol-specific traffic
which is sent over a LLC-configured thread is placed in a datagram frame.

The goal of the LLC and its session manager is to expose an API to endpoints that enables
them to create link connections to external endpoints to exchange ICN protocol-specific
traffic. For example, the API of this LLC session manager might be:

udp_connect(ip_address string, port int, protocolIdentifier string)
tcp_connect(ip_address string, port int, protocolIdentifier string)
ip_connect(ip_address string, protocolIdentifier string)
mac_connect(mac_address string, protocolIdentifier string)

In all cases, the "protocolIdentifier" parameter is a well-defined name for the
ICN protocol to use. For example,

protocolIdentifier = {'ccnx10, ndn'}

<!-- Cast (who plays a role), notation

  - assumption about the transport channel (=link), "magic that happened before"
  - "pipeline picture" - link, session, session manager, threads
  - rpc pattern, negotiation style
  - "outer entities", its API towards the session manager -->

Scope of document:

The rest of this document outlines the exact definition and notation used in the description
of the LLC, the relevant concepts necessary to understand the protocol, a high-level
description of the protocol (along with message content), and the encoding details
of each message.

  <!-- - concepts
  - high level protocol for specific negotiation tasks: (initSession, startSecureAssociation,
    inspection, setMTU, create and destroy logical links)
  - encodings? at least for RPC-request, RPC-response and DATAGRAM
  - -->

Definitions and Notation
========================

The following terms are used:

endpoint: An endpoint which is capable of supporting at least one ICN protocol.

link: A logical connection between two endpoints.

sender: An endpoint which is sending a message from to another session over a link.

sender: An endpoint which is receiving a message from another session over a link.

session: A semi-permanent context in which information is (possibly encrypted and) exchanged
over a link between two endpoints.

session manager: A control unit responsible for managing a session between two endpoints.

thread: An isolated and ephemeral context managed by a session manager in which
ICN-specific traffic is sent between two endpoints.

RPC-request: A request to perform an RPC action from a sender to a receiver.

RPC-response: A response to an RPC-request sent from RPC-request receiver to the
RPC-request sender.

datagram: A message that encapsulates protocol-specific traffic (e.g., an ICN
interest or content object).

LLC Concepts
============

Assumptions
-----------
The LLC protocol makes the following assumptions:

* The communication parameters necessary to communicate over a link are
established before the protocol is executed. This includes settings that,
for example, enable bidirectional firewall traversal.

* The underlying link protocol provides the most basic ability to encapsulate
and move an arbitrary sized payload from one endpoint to another. 

* Each endpoint has an identity and can prove its identity to the other endpoints
associated with links.

* Endpoints are configured with the identities that they trust, i.e., those endpoints
that are allowed to participate in the execution of the LLC protocol. These identities
could be ascertained online or configured manually by system administrators.

cast
----
[cft], incl picture

negotiation style
-----------------
[cft]

Endpoints Entities
------------------
Each endpoint has an associated entity that is responsible for initating links
between other endpoints to exchange ICN traffic. Each of these entities interfaces
with the LLC protocol using the LLC API, which is outlined below:

int udp_connect(ip_address string, port int, protocolIdentifier string): create a new connection
to the endpoint at the specified IP address and port using UDP as the transport mechanism.
int tcp_connect(ip_address string, port int, protocolIdentifier string): create a new connection
to the endpoint at the specified IP address and port using TCP as the transport mechanism.
int ip_connect(ip_address string, protocolIdentifier string): create a new connection
to the endpoint at the specified IP address.
int mac_connect(mac_address string, protocolIdentifier string): create a new connection to
the endpoint at the specified MAC address.

In all cases, the "protocolIdentifier" parameter is a well-defined name for the
ICN protocol to use. For example,

protocolIdentifier = {'ccnx10, ndn'}

The return value for these functions is a unique identifier that the LLC session manager
uses to identify links and sessions. It is used when an entity wishes to teardown a 
given link using the function specified below.

void connection_teardown(connectionId int): teardown and destroy all state associated with the
specified connection ID.

link-level RPC (and the three msgs)
===================================

[cft]


Negotiation Tasks
=================

a) [cw]
--

Encoding (of RPC and parameters)
================================

RPC verbs
---------

RPC parameters
--------------

three msg headers
-----------------


Security Considerations
=======================

yes

--- back


Examples  {#xmp}
========
