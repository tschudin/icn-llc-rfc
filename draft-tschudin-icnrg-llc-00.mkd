---
title: Logical Link Control for ICN Protocols
abbrev: ICN-LLC
docname: draft-tschudin-icnrg-llc-00
date: 2015-08-27
category: info

ipr: trust200902
area: General
workgroup: ICNRG Working Group
keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: C. Tschudin
    name: Christian Tschudin
    organization: University of Basel
    email: christian.tschudin@unibas.ch
 -
    ins: C. A. Wood
    name: Christopher A. Wood
    org: PARC
    email: cwood@parc.com

normative:
---  RFC2119:
---  RFC3986:
---  RFC4086:
---  RFC4648:

informative:
---  RFC5389:
---  I-D.ietf-behave-turn:
---  STUNT:
---    target: http://deusty.blogspot.com/2007/09/stunt-out-of-band-channels.html
---    title: STUNT & out-of-band channels
---    author:
---      name: Robbie Hanson
---      ins: R. Hanson
---    date: 2007-09-17
---  I-D.meyer-xmpp-e2e-encryption:
---  I-D.ietf-xmpp-3920bis:



--- abstract

abc

--- middle

Introduction        {#problems}
============

This document specifies a logical link control (LLC) protocol to
establish a secure association between two endpoints running ICN
software.  It consists of a negotiation method to explore, configure,
and manage the essential parameters for communication, permitting to
switch from unsecured message exchange to encrypted and authenticated
communications. It also supports the dynamic creation of logical links
on a per-protocol basis, permitting to use the link for multiple ICN
protocols such as CCNx and NDN, in parallel.

It is assumed that two endpoints executing the LLC have already
discovered each other and configured their lower-layer transport
mechanism to enable bidirectional communication.  A single session is
establish over this link for end-to-end control. This session is used
to control, for example, the link MTU size before encryption is turned
on between the two endpoints. Within this session, encrypted logical
channels, called threads, are established both for control and for
production traffic. Each endpoint is authenticated during this stage.

<!--
Finally, after the encrypted control channel is established, per-protocol communication
channels, or threads, can be instantiated within the context of the link session.
-->
<!-- A session manager is responsible for handling the control messages exchanged between
endpoints in the context of a given session. -->
<!--
Threads are used to send protocol-specific traffic go a remote "packet
handler". For example, two endpoints with an established session could
create two separate threads for CCNx and NDN traffic. Threads are
unidirectional but are often used in pairs (to have bidirectionality). -->

The hierarchy of control in the LLC is shown below.

~~~
+------------------------------------------------+
|        1 Link (bidirectional transport)        |
|  +------------------------------------------+  |
|  |     1 Session                            |  |
|  |   +-----------------------------------+  |  |
|  |   | N Threads (= undirect. log. link) |  |  |
|  |   +-----------------------------------+  |  |
|  +------------------------------------------+  |
+------------------------------------------------+
~~~
{: #llc-hierarchy title="Control hierarchy in the LLC."}

All control (e.g., negotiation) messages follow an RPC-style model. That is, a RPC-request
has an identity for the parent context (e.g., the session), an action (verb) that identifies
the action to be done, and additional parameters. Each RPC-request is followed by
an RPC-response which specifies the result of the operation, e.g., an OK flag
or a FAIL flag with some useful error information.

<!-- All protocol-specific traffic
which is sent over a LLC-configured thread is placed in a datagram frame.
-->

Scope of document:

The rest of this document outlines the exact definition and notation used in the description
of the LLC, the relevant concepts necessary to understand the protocol, a high-level
description of the protocol (along with message content), and the encoding details
of each message.

  <!-- - concepts
  - high level protocol for specific negotiation tasks: (initSession, startSecureAssociation,
    inspection, setMTU, create and destroy logical links)
  - encodings? at least for RPC-request, RPC-response and DATAGRAM
  - -->

Definitions and Notation
========================

The following terms are used:

endpoint: A (session) endpoint which is capable of supporting at least
one ICN protocol, for example an IP node reachable via UDP.

link: A bidirectional datagram service between two endpoints (e.g., UDP, Ethernet).

<!--
sender: An endpoint which is sending a message from to another session over a link.

sender: An endpoint which is receiving a message from another session over a link.
-->

session: A semi-permanent context in which (possibly encrypted) information is exchanged
over a link between two endpoints.

session manager: A control unit responsible for managing a session between two endpoints.

thread, or logical link: An isolated and ephemeral context managed by a session manager in which encrypted
traffic is sent between two endpoints.

RPC-request: A request to perform an RPC action from a sender to a receiver.

RPC-response: A response to an RPC-request sent from RPC-request receiver to the
RPC-request sender.

<!-- datagram: A message that encapsulates protocol-specific traffic (e.g., an ICN
interest or content object).
-->


LLC Concepts
============

Assumptions
-----------
The LLC protocol makes the following assumptions:

* The communication parameters necessary to communicate over a link are
established before the protocol is executed. This includes settings that,
for example, enable bidirectional firewall traversal.

* The underlying link protocol provides the most basic ability to encapsulate
and move an arbitrary sized payload from one endpoint to another.

* Each endpoint has an identity and can prove its identity to the other endpoints
associated with links.

* Endpoints are configured with the identities that they trust, i.e., those endpoints
that are allowed to participate in the execution of the LLC protocol. These identities
could be ascertained online or configured manually by system administrators.

cast
----
[cft], incl picture

<!-- Cast (who plays a role), notation

  - assumption about the transport channel (=link), "magic that happened before"
  - "pipeline picture" - link, session, session manager, threads
  - rpc pattern, negotiation style
  - "outer entities", its API towards the session manager -->

~~~
the fig
~~~
{: #llc-cast title="Entities (all claiming to be end points 8-)."}


negotiation style
-----------------
[cft]

Endpoints Entities (and an API for ICN-LLC)
-------------------------------------------

The goal of the LLC and its session manager is to expose an API that
enables a run-time environment to connect local ICN software like a CCNx forwarder to a
remote peer, reusing the LLC's secured link. For example, the API could be structured 
as follows:

int udp_connect(ip_address string, port int, protocolIdentifier string): create a new connection
to the endpoint at the specified IP address and port using UDP as the transport mechanism.
int tcp_connect(ip_address string, port int, protocolIdentifier string): create a new connection
to the endpoint at the specified IP address and port using TCP as the transport mechanism.
int ip_connect(ip_address string, protocolIdentifier string): create a new connection
to the endpoint at the specified IP address.
int mac_connect(mac_address string, protocolIdentifier string): create a new connection to
the endpoint at the specified MAC address.

In all cases, the "protocolIdentifier" parameter is a well-defined name for the
ICN protocol to use. For example,

protocolIdentifier = {'ccnx10, ndn'}

The return value for these functions is a unique identifier that the LLC session manager
uses to identify links and sessions. It is used when an entity wishes to teardown a
given link using the function specified below.

void connection_teardown(connectionId int): teardown and destroy all state associated with the
specified connection ID.

<!--
 For example, the API of this LLC session manager might be:

udp_connect(ip_address string, port int, protocolIdentifier string)
tcp_connect(ip_address string, port int, protocolIdentifier string)
ip_connect(ip_address string, protocolIdentifier string)
mac_connect(mac_address string, protocolIdentifier string)

In all cases, the "protocolIdentifier" parameter is a well-defined name for the
ICN protocol to use. For example,

protocolIdentifier = {'ccnx10, ndn'}
-->



Link-level RPC and Logical Link Traffic
=======================================

All configuration state of a session, including state related to the
session's threads, are managed by remote procedure operations. To this
end, two message types "RPC-request" and "RPC-response" are needed. A
third message type is added to this set for actual production (=
non-control) traffic, called "logical link traffic".  We describe each
of these three message types and their mandatory fields in an
encoding-neutral way. See section X for the actual code points.

We first show the list of data structures before explaining each of
them.

~~~
    rpc-request (RID, verb, parameter-list)
    rpc-response(RID, OK|FAIL, result-list|reason-list)
    llt-message (LID, blob)

    RID = rid(SID, nonce)   # request ID
    LID = lid(SID, TID)     # logical link ID
    SID = sid(val1, val2)   # session ID
    TID = tid(val1, val2)   # thread ID
~~~
{: #llc-msgs title="The three message types of ICN-LLC."}

RPC-request
-----------

(See also Figure [#llc-msgs]) An RPC-request message carries an ID
that identifyies the request instance (RID) as well as a verb and an
optional payload with the list of parameters.

The RID carries two pieces of information: The current session's ID
(SID) comes first, followed by a nonce. The role of the SID is to
refer to previously established state and must be kept constant for
all messages sent inside the established session. The Nonce is
randomly chosen for each new RPC-request and permits to retransmit a
request in case the sender thinks that the request or the reply got
lost. It is not a sequence number, though.


RPC-response
------------

An RPC-response is always the reaction to a received RPC-request. It
contains a copy of the request's RID so that the requestor can
correlate the answer with the pending request. Furthermore, the
RPC-response has a verb similar to the RPC-request. However, the
permitted verbs are limited to either "OK" or "FAIL".


Logical Link Traffic
--------------------

Logical Link Traffic refers to the messages that travel inside a
logical link (called thread). This message type has three fields: tag,
logical link ID and payload.

The logical link is identified by a tuple that refers to the session
context (SID) as well as the thread to which this message belongs
to. In fact, the <SID, TID> tuple is a "network pointer" into the
other end's function space [NetPtrs]. The thread ID is also a tuple,
in this case of two numbers. Often, threads are used in pairs in which
case the tuple's values are swapped.


Negotiation Tasks
=================

We now describe the major negotiation tasks (RPC calls) that make up
the LLC protocol.  Any side can initiate an RPC at any time. It is
suggested to limit the number of RPCs that one side issues in parallel
to four (including nesting).

{REMOVE? For simplicity, we refer to each of the endpoints in the
protocol as Q for Questioner and R for Responder. Or use P1 and P2, or
P1 and EP2 for endpoint?}


Session Initialization
----------------------

The session initialization task is the first step in establishing and
using a link between two endpoints. Assuming such a communication link
for the underlying transport protocol is established, it is done by
the following RPC exchange.

~~~
  --> rpc-request(rid(SID-1,0), nonce), START-SESSION, list())

                                                 On success:
  <-- rpc-response(rid(SID-1,0), nonce), OK, list(SID-2))
                                                 On failure:
  <-- rpc-response(rid(SID-1,0), nonce), FAIL, list(<reason>))
~~~
{: #session-init title="Session Initialization Message Exchange."}

After that exchange was executed, both ends will use the session ID
consisting of SID-1 and SID-2 i.e., sid(SID-1,SID-2) in order to refer
to this new session. In the following we abbreviate this tuple to SID.

Note that session initialization leaves the two endpoints in an
unsecure state until they have executed the secure association task
(see below).

{Question: how to handle/mitigate an attcker injecting
such "reset" messages?|

Inspection
----------

Inspection messages may be used to recover generic information
from an endpoint, e.g., the preferred MTU size. The RPC exchange
for an inspection message is as follows.

~~~
  --> rpc-request(rid(SID, nonce), “lookup", list("/conf/PreferredMTU"))

                                                   On success:
  <-- rpc-response(rid(SID, nonce), OK, list(<MTU value>))
                                                   On failure:
  <-- rpc-response(rid(SID, nonce), FAIL, list(<reason>))
~~~
{: #inspection-msg title="Remote inspection (for MTU)."}

Inspection messages may be used to query any well-named object from
the recipient endpoint. In the example above, the inspection for the
preferred MTU would usually occur before establishing a secure session
association (SA).  Thus, before SA, the contents of the RPC request
and response are unencrypted.  However, after a SA is established, all
inspection messages will be encrypted like other link traffic.

Secure Association Establishment
--------------------------------

The secure association (SA) establishment message exchange is used to
create a secure session over a given link. This enables all subsequent
traffic, including RPC exchanges, to be authenticated and
encrypted. The goal is for each endpoint to authenticate the entity
running on the other endpoint of a given link, and to then establish
shared symmetric keys to perform authenticated encryption of all
traffic that follows the exchange.  Currently, we specify a simple
challenge-response mutual authentication protocol.  This can be
replaced with any functionally equivalent protocol.

Note that the SA involves nested RPCs: The responder to the initial
RPC request will do an RPC in reverse direction in order to
authenticate the requestor.

Note also that encrypt(K,M) stands for the ciphertext resulting from
applying key K to message M.

~~~
  --> rpc-request(rid(SID, nonceA), “prove-identity",
                  list(nil, <optionsA>, <keyshareA>,
                       NULL, <challengeA-1, challengeA-2>))

      <-- rpc-request(rid(SID, nonceB), “prove-identity"
                      list((nonceA, <optionsB>, <keyshareB>,
                           NULL, <challengeB-1, challengeB-2>))
      --> rpc-response(rid(SID, nonceB), OK,
                      list(signature(key-P1, challengeB-1),
                           encrypt(keyAB, list(TIDa, challengeB-2, nonceB)))

  <-- rcp-response(rid(SID, nonceA), OK,
                   list((signature(key-P2, challengeA-1),
                        encrypt(keyAB, list(TIDb, challengeA-2, nonceA)))
~~~
{: #sa-init title="Secure Association with two challenge-response rounds."}

In the first message, the value nil is used to represent an empty nonce.

optionsA and optionsB are key-value data structure that contain the following
information, at a minimum:

* Preferred identity information (e.g., the form of signature algorithm to use
    when processing the challenge and response).
* Diffie Hellman group parameters

The key key-Pi = private key of Pi or key shared between P1 and P2.

Lastly, keyAB is the key material derived from the output of the
Diffie Hellman exchange with the shares keyshareA and keyshareB. That
is, logically,

    keyAB = DH(keyshareA, keyshareB)

When a failure occurs in the secure association RPC (not shown in the
digram above), the recipient replies with an error code (in clear) as
in the Inspection message case and does not establish a new (or
replace an old) secured logical link.

<!-- was: terminates the session state information -->

Otherwise the secure association request succeeded and from this point
in time on the two endpoints will exchange their control messages in
encrypted form inside threads.

To this end, the protocol above exchanged and authenticated two
endpoint-chosen numbers TIDa and TIDb.  The thread starting from the
side that chose the TIDa value will use thread ID TIDAB=(TIDa,
TIDb) while the other side can use thread TIDBA=(TIDb,TIDa) to reply.

For example, the remote inspection RPC can now be executed in a secured
fashion as follows:

  --> llt-message(TIDAB, encrypt(keyAB, rpc-request(rid(SID, nonce),
                                  “lookup", list("/conf/PreferredMTU"))))

                                                   On success:
  <-- llt-message(TIDBA, encrypt(keyAB, rpc-response(rid(SID, nonce),
                                  OK, list(<MTU value>))))
~~~

//// I stoped editing here (cft)


Set MTU
-------

Setting the MTU is a standard message in the LLC protocol that has
the following RPC exchange format.

~~~
P1                                                   P2
            rpc-request(id=(SID, TID-0, nonce),
              “Enc(keyAB, set(MTU, <value>))”)
            ---------------------------->  

                                            On success:
            rpc-response(id=(SID, TID-0, nonce),
              Enc(keyAB, result(OK, (<value>)))
            <----------------------------

                                            On failure:
            rpc-response(id=(SID, TID-0, nonce),
              Enc(keyAB, result(FAIL, <reason>)))
            <----------------------------
~~~
{: #set-mtu-msg title="Set the MTU."}

Create and Destroy Logical Links (Threads)
------------------------------------------

After a session and SA have been established, the protocol-specific links (threads) must be
created. This is done with the following exchange.

~~~
P1                                                    P2
            rpc-request(id=(SID, TID-0, nonce),
              Enc(keyAB, “create-thread(TID-5a, key,
              'icn-protocol-identifier')”))
            ---------------------------->  

                                             On success:
            rpc-response(id=(SID, TID-0, nonce),
              Enc(keyAB, result=(OK, TID-5b)))
            <----------------------------

                                             On failure:
            rpc-response(id=(SID, TID-0, nonce),
              Enc(keyAB, result=(FAIL, <reason>)))
            <----------------------------
~~~
{: #thread-create title="Logical Link (Thread) Creation."}

Note that this is an imperative procedure. Since each thread is owned
and controlled by the session manager, it is sufficient for the session
manager to simply derive a new encryption key "key" for the thread
during creation. In other words, it is not necessary to perform another
multi-round Diffie Hellman key exchange.

Also, in this case, the failure reasons could be one of:

* "Protocol not supported"
* "Invalid key size"

Currently, each thread will use the same encryption algorithm and parameters
for their respective traffic. This could be changed by allowing endpoints
to negotiate these parameters during the thread creation exchange.

Finally, when a thread is finished, it must be destroyed and all state
must be recycled. This is done with the following exchange.

~~~
P1                                                  P2
            rpc-request(id=(SID, TID-0, nonce),
              Enc(keyAB, “destroy-thread(TID-5)”))
            ---------------------------->  

            rpc-response(id=(SID, TID-0, nonce),
              Enc(keyAB, result=(OK, TID-5)))
            <----------------------------
~~~
{: #thread-destroy title="Logical Link (Thread) Destruction."}

After this exchange, both parties tear down and recycle their local state.
Moreover, this destroy request is idempotent; attempting to destroy a non-existent
thread will yield an OK response from the recipient.

<!-- initSession, startSecureAssociation, inspection, setMTU, create and destroy logical links -->

Encoding (of RPC and parameters)
================================

RPC verbs
---------

RPC parameters
--------------

three msg headers
-----------------


Security Considerations
=======================

yes

--- back


Examples  {#xmp}
========
