---
title: Logical Link Control for ICN Protocols
abbrev: ICN-LLC
docname: draft-tschudin-icnrg-llc-00
date: 2015-08-27
category: info

ipr: trust200902
area: General
workgroup: ICNRG Working Group
keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: C. Tschudin
    name: Christian Tschudin
    organization: University of Basel
    email: christian.tschudin@unibas.ch
 -
    ins: C. A. Wood
    name: Christopher A. Wood
    org: PARC
    email: cwood@parc.com

normative:
  RFC2119:
  RFC3986:
  RFC4086:
  RFC4648:

informative:
  RFC5389:
  I-D.ietf-behave-turn:
  STUNT:
    target: http://deusty.blogspot.com/2007/09/stunt-out-of-band-channels.html
    title: STUNT & out-of-band channels
    author:
      name: Robbie Hanson
      ins: R. Hanson
    date: 2007-09-17
  I-D.meyer-xmpp-e2e-encryption:
  I-D.ietf-xmpp-3920bis:



--- abstract

abc

--- middle

Introduction        {#problems}
============

This document specifies a logical link control (LLC) protocol to facilitate interoperability
and coexistence of ICN protocols such as CCNx and NDN. The goal of the LLC protocol
is to perform link negotiation between two endpoints to name, configure, and manage
the essential parameters for communication. This negotiation process is used to
establish a secure link between two endpoints through which all traffic is (or
can be) encrypted and authenticated.

The LLC negotiates the parameters for and manages a logical link between two endpoints.
It is assumed that two endpoints executing the LLC have already discovered each other
and configured their lower-layer transport mechanism to enable end-to-end communication.
A single session is establish over this link for end-to-end control. This session is
used to control, for example, the link MTU size before an encrypted channel has been
setup between the two endpoints. Within this session, an encrypted control channel is
established for further control messages; each endpoint is authenticated during this
stage.

Finally, after an encrypted control channel is established, per-protocol communication
channels, or threads, can be instantiated within the context of the link session.
A session manager is responsible for handling the control messages exchanged between
endpoints in the context of a given session. These individual threads are used to send
protocol-specific traffic between the two endpoints. For example, two endpoints with an established
session could create two separate threads for CCNx and NDN traffic.

The hierarchy of control in the LLC is shown below.

~~~
+-------------------------------------+
|                Link                 |
|  +-------------------------------+  |
|  |            Session            |  |
|  |   +------------------------+  |  |
|  |   |         Thread         |  |  |
|  |   +------------------------+  |  |
|  +-------------------------------+  |
+-------------------------------------+
~~~
{: #llc-hierarchy title="Control hierarchy in the LLC."}

All control (e.g., negotiation) messages follow RPC-style model. That is, a RPC-request
has an identity for the parent context (e.g., the session), an action (verb) that identifies
the action to be done, and additional parameters. Each RPC-request is followed by
an RPC-response which specifies the result of the operation, e.g., an OK flag
or a FAIL flag with some useful error information. All protocol-specific traffic
which is sent over a LLC-configured thread is placed in a datagram frame.

The goal of the LLC and its session manager is to expose an API to endpoints that enables
them to create link connections to external endpoints to exchange ICN protocol-specific
traffic. For example, the API of this LLC session manager might be:

udp_connect(ip_address string, port int, protocolIdentifier string)
tcp_connect(ip_address string, port int, protocolIdentifier string)
ip_connect(ip_address string, protocolIdentifier string)
mac_connect(mac_address string, protocolIdentifier string)

In all cases, the "protocolIdentifier" parameter is a well-defined name for the
ICN protocol to use. For example,

protocolIdentifier = {'ccnx10, ndn'}

<!-- Cast (who plays a role), notation

  - assumption about the transport channel (=link), "magic that happened before"
  - "pipeline picture" - link, session, session manager, threads
  - rpc pattern, negotiation style
  - "outer entities", its API towards the session manager -->

Scope of document:

The rest of this document outlines the exact definition and notation used in the description
of the LLC, the relevant concepts necessary to understand the protocol, a high-level
description of the protocol (along with message content), and the encoding details
of each message.

  <!-- - concepts
  - high level protocol for specific negotiation tasks: (initSession, startSecureAssociation,
    inspection, setMTU, create and destroy logical links)
  - encodings? at least for RPC-request, RPC-response and DATAGRAM
  - -->

Definitions and Notation
========================

The following terms are used:

endpoint: An endpoint which is capable of supporting at least one ICN protocol.

link: A logical connection between two endpoints.

sender: An endpoint which is sending a message from to another session over a link.

sender: An endpoint which is receiving a message from another session over a link.

session: A semi-permanent context in which information is (possibly encrypted and) exchanged
over a link between two endpoints.

session manager: A control unit responsible for managing a session between two endpoints.

thread: An isolated and ephemeral context managed by a session manager in which
ICN-specific traffic is sent between two endpoints.

RPC-request: A request to perform an RPC action from a sender to a receiver.

RPC-response: A response to an RPC-request sent from RPC-request receiver to the
RPC-request sender.

datagram: A message that encapsulates protocol-specific traffic (e.g., an ICN
interest or content object).

LLC Concepts
============

Assumptions
-----------
The LLC protocol makes the following assumptions:

* The communication parameters necessary to communicate over a link are
established before the protocol is executed. This includes settings that,
for example, enable bidirectional firewall traversal.

* The underlying link protocol provides the most basic ability to encapsulate
and move an arbitrary sized payload from one endpoint to another.

* Each endpoint has an identity and can prove its identity to the other endpoints
associated with links.

* Endpoints are configured with the identities that they trust, i.e., those endpoints
that are allowed to participate in the execution of the LLC protocol. These identities
could be ascertained online or configured manually by system administrators.

cast
----
[cft], incl picture

negotiation style
-----------------
[cft]

Endpoints Entities
------------------
Each endpoint has an associated entity that is responsible for initating links
between other endpoints to exchange ICN traffic. Each of these entities interfaces
with the LLC protocol using the LLC API, which is outlined below:

int udp_connect(ip_address string, port int, protocolIdentifier string): create a new connection
to the endpoint at the specified IP address and port using UDP as the transport mechanism.
int tcp_connect(ip_address string, port int, protocolIdentifier string): create a new connection
to the endpoint at the specified IP address and port using TCP as the transport mechanism.
int ip_connect(ip_address string, protocolIdentifier string): create a new connection
to the endpoint at the specified IP address.
int mac_connect(mac_address string, protocolIdentifier string): create a new connection to
the endpoint at the specified MAC address.

In all cases, the "protocolIdentifier" parameter is a well-defined name for the
ICN protocol to use. For example,

protocolIdentifier = {'ccnx10, ndn'}

The return value for these functions is a unique identifier that the LLC session manager
uses to identify links and sessions. It is used when an entity wishes to teardown a
given link using the function specified below.

void connection_teardown(connectionId int): teardown and destroy all state associated with the
specified connection ID.

link-level RPC (and the three msgs)
===================================

[cft]

@Christian: maybe you can also describe the notation of the language here? e.g., P1->P2: XXX means "P1 sends XXX to P2"

Negotiation Tasks
=================

We now describe the major negotiation tasks (message exchanges) that make up
the LLC protocol. For simplicity, we refer to each of the endpoints in the
protocol as P1 and P2.

Session Initialization
----------------------

The session initialization task is the first step in establishing and using a link
between two endpoints. Assuming a communication link for the underlying transport protocol
is established, it is done by the following RPC exchange.

~~~
P1                                                 P2
        rpc-request(id=(SID-1), "start-session”)
            ---------------------------->  

                                            On success:
      rpc-response: (id=(SID-1), result(OK, SID-2))
            <----------------------------

                                            On failure:
      rpc-response(id=(SID-1), result(FAIL, <reason>))
            <----------------------------
~~~
{: #session-init title="Session Initialization Message."}

The session identifier SID is treated as the tuple (SID-1, SID-2)
after the completion of this exchange.

Inspection
----------

Inspection messages may be used to recover generic information
from an endpoint, e.g., the preferred MTU size. The RPC exchange
for an inspection message is as follows.

~~~
P1                                                         P2
    rpc-request(id=(SID, TID-0, nonce), “lookup(MTU)")
            ---------------------------->  

                                                   On success:
rpc-response(id=(SID, TID-0, nonce),  result(OK, <MTU value>))
            <----------------------------

                                                   On failure:
rpc-response(id=(SID, TID-0, nonce),  result(FAIL, <reason>))
            <----------------------------
~~~
{: #inspection-msg title="Inspection (for MTU)."}

In this context, TID-0 is the standard control channel for
the session. All threads that are spawned in the context of session
SID will be assigned different identifiers.

Inspection messages may be used to query any well-named object from
the recipient endpoint. In the example above, the inspection for the MTU
would usually occur before establishing a secure session association (SA).
Thus, the contents of the RPC request and response are unencrypted.
However, after a SA is established, all inspection messages will be
encrypted like other link traffic.

Secure Association Establishment
--------------------------------

The secure association (SA) establishment message exchange is used to
create a secure session over a given link. This enables all subsequent
traffic to be authenticated and encrypted. The goal is for each endpoint
to authenticate the entity running on the other endpoint of a given link,
and to then establish shared symmetric keys to perform authenticated
encryption of all traffic that follows the exchange.
Currently, we specify a simple challenge-response mutual authentication protocol.
This can be replaced with any functionally equivalent protocol.

~~~
P1                                                                P2
    rpc-request(id=(SID, TID-0, nonceA),
      “prove-identity(nil, <optionsA>, <keyshareA>,
      NULL, <challengeA-1, challengeA-2>)”)
            ---------------------------->  

    rpc-request(id=(SID, TID-0, nonceB),
      “prove-identity(nonceA, <optionsB>, <keyshareB>,
      NULL, <challengeB-1, challengeB-2>)”)
            <----------------------------

    rpc-response(id=(SID, TID-0, nonceB),
      result=(OK, challenge-response(signature(key-P1, challengeB-1),
      encrypt(keyAB, (challengeB-2, nonceB)))
            ---------------------------->

    rcp-response(id=(SID, TID-0, nonceA),
      result=(OK, challenge-response(signature(key-P2, challengeA-1),
      encrypt(keyAB, (challengeA-2, nonceA)))
           <----------------------------
~~~
{: #sa-init title="Session Initialization Message."}

In the first message, the value nil is used to represent an empty nonce.

optionsA and optionsB are key-value data structure that contain the following
information, at a minimum:

* Preferred identity information (e.g., the form of signature algorithm to use
    when processing the challenge and response).
* Diffie Hellman group parameters

The key key-Pi = private key of Pi or key shared between P1 and P2. Lastly,
keyAB is the ket material derived from the output of the Diffie Hellman exchange
with the shares keyshareA and keyshareB. That is, logically,

    keyAB = DH(keyshareA, keyshareB)

Note that the above exchange only includes the success case. When a failure occurs,
the recipient replies with an error code as in the Inspection message case and
terminates the session state information.

Set MTU
-------

Setting the MTU is a standard message in the LLC protocol that has
the following RPC exchange format.

~~~
P1                                                   P2
            rpc-request(id=(SID, TID-0, nonce),
              “Enc(keyAB, set(MTU, <value>))”)
            ---------------------------->  

                                            On success:
            rpc-response(id=(SID, TID-0, nonce),
              Enc(keyAB, result(OK, (<value>)))
            <----------------------------

                                            On failure:
            rpc-response(id=(SID, TID-0, nonce),
              Enc(keyAB, result(FAIL, <reason>)))
            <----------------------------
~~~
{: #set-mtu-msg title="Set the MTU."}

Create and Destroy Logical Links (Threads)
------------------------------------------

After a session and SA have been established, the protocol-specific links (threads) must be
created. This is done with the following exchange.

~~~
P1                                                    P2
            rpc-request(id=(SID, TID-0, nonce),
              Enc(keyAB, “create-thread(TID-5a, key,
              'icn-protocol-identifier')”))
            ---------------------------->  

                                             On success:
            rpc-response(id=(SID, TID-0, nonce),
              Enc(keyAB, result=(OK, TID-5b)))
            <----------------------------

                                             On failure:
            rpc-response(id=(SID, TID-0, nonce),
              Enc(keyAB, result=(FAIL, <reason>)))
            <----------------------------
~~~
{: #thread-create title="Logical Link (Thread) Creation."}

Note that this is an imperative procedure. Since each thread is owned
and controlled by the session manager, it is sufficient for the session
manager to simply derive a new encryption key "key" for the thread
during creation. In other words, it is not necessary to perform another
multi-round Diffie Hellman key exchange.

Also, in this case, the failure reasons could be one of:

* "Protocol not supported"
* "Invalid key size"

Currently, each thread will use the same encryption algorithm and parameters
for their respective traffic. This could be changed by allowing endpoints
to negotiate these parameters during the thread creation exchange.

Finally, when a thread is finished, it must be destroyed and all state
must be recycled. This is done with the following exchange.

~~~
P1                                                  P2
            rpc-request(id=(SID, TID-0, nonce),
              Enc(keyAB, “destroy-thread(TID-5)”))
            ---------------------------->  

            rpc-response(id=(SID, TID-0, nonce),
              Enc(keyAB, result=(OK, TID-5)))
            <----------------------------
~~~
{: #thread-destroy title="Logical Link (Thread) Destruction."}

After this exchange, both parties tear down and recycle their local state.
Moreover, this destroy request is idempotent; attempting to destroy a non-existent
thread will yield an OK response from the recipient.

<!-- initSession, startSecureAssociation, inspection, setMTU, create and destroy logical links -->

Encoding (of RPC and parameters)
================================

RPC verbs
---------

RPC parameters
--------------

three msg headers
-----------------


Security Considerations
=======================

yes

--- back


Examples  {#xmp}
========
