---
title: Logical Link Control for ICN Protocols
abbrev: ICN-LLC
docname: draft-tschudin-icnrg-llc-00
date: 2015-08-30
category: info

ipr: trust200902
area: General
workgroup: ICNRG Working Group
keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: C. Tschudin
    name: Christian Tschudin
    organization: University of Basel
    email: christian.tschudin@unibas.ch
 -
    ins: C. A. Wood
    name: Christopher A. Wood
    org: PARC
    email: cwood@parc.com

normative:
---  RFC2119:
---  RFC3986:
---  RFC4086:
---  RFC4648:

informative:
---  RFC5389:
---  I-D.ietf-behave-turn:
---  STUNT:
---    target: http://deusty.blogspot.com/2007/09/stunt-out-of-band-channels.html
---    title: STUNT & out-of-band channels
---    author:
---      name: Robbie Hanson
---      ins: R. Hanson
---    date: 2007-09-17
---  I-D.meyer-xmpp-e2e-encryption:
---  I-D.ietf-xmpp-3920bis:



--- abstract

abc

--- middle

Introduction        {#problems}
============

This document specifies a logical link control (LLC) protocol to
establish a secure association between two endpoints running ICN
software.  It consists of a negotiation method to explore, configure,
and manage the essential parameters for communication, permitting to
switch from unsecured message exchange to encrypted and authenticated
communications. It also supports the dynamic creation of logical links
on a per-protocol basis, permitting to use the link for multiple ICN
protocols such as CCNx and NDN, in parallel.

It is assumed that two endpoints executing the ICN-LLC protocol have already
discovered each other and configured their lower-layer transport
mechanism to enable bidirectional communication.  A single session is
establish over this link for end-to-end control. This session is used
to control, for example, the session (and in consequence also the
ICN protocols') MTU size before encryption is turned
on between the two endpoints. Within this session, encrypted logical
channels, called pipes, are established both for control and for
production traffic. Each endpoint is authenticated during this stage.

<!--
Finally, after the encrypted control channel is established, per-protocol communication
channels, or threads, can be instantiated within the context of the link session.
-->
<!-- A session manager is responsible for handling the control messages exchanged between
endpoints in the context of a given session. -->
<!--
Threads are used to send protocol-specific traffic go a remote "packet
handler". For example, two endpoints with an established session could
create two separate threads for CCNx and NDN traffic. Threads are
unidirectional but are often used in pairs (to have bidirectionality). -->

The hierarchy of control in ICN-LLC is shown below.

~~~
  +-----------------------------------------------+
  |        1 Link (bidirectional transport)       |
  |  +-----------------------------------------+  |
  |  |     1 Session                           |  |
  |  |   +----------------------------------+  |  |
  |  |   | N Pipes (= undirect. log. links) |  |  |
  |  |   +----------------------------------+  |  |
  |  +-----------------------------------------+  |
  +-----------------------------------------------+
~~~
{: #llc-hierarchy title="Control hierarchy in the LLC."}

All control (e.g., negotiation) messages follow an Remote Procedure
Call-style (RPC) model. That is, an RPC-request has an identity for
the parent context (session) and a unique call identifier, an action
(verb) that identifies the action to be done as well as additional
action-specific parameters. Each RPC-request is followed by an
RPC-response which specifies the result of the operation, e.g., an OK
flag or a FAIL flag with some useful error information.

The goal of the ICN-LLC service is to provide a framework that enables
two parties to negotiate session and pipe properties. For example,
pipes could be configured to provide reliable and ordered datagram
delivery, or endpoints could negotiate traffic control parameters on a
per-session or per-pipe basis. The design of ICN-LLC's RPC approach is
extensible enough in order to support a variety of endpoint- and
application-specific link management requirements.

Scope of document:

The rest of this document introduces definitions and notation used in
the description of the ICN-LLC protocol, outlines the relevant
concepts and then provides a high-level description of the protocol
(along with message content) as well as the encoding details of each
message. A full encoding example completes this document.

  <!-- - concepts
  - high level protocol for specific negotiation tasks: (initSession, startSecureAssociation,
    inspection, setMTU, create and destroy logical links)
  - encodings? at least for RPC-request, RPC-response and DATAGRAM
  - -->

Definitions and Notation
========================

The following terms are used:

* endpoint: A (session) endpoint which is capable of supporting at
  least one ICN protocol, for example an IP node reachable via UDP.

* link: A bidirectional datagram service between two endpoints (e.g.,
  UDP, Ethernet).

* session: A semi-permanent context in which (possibly encrypted)
  information is exchanged over a link between two endpoints.

* session manager: A control unit responsible for managing a session
  between two endpoints.

* pipe, or logical link: An isolated and ephemeral context managed
  by a session manager in which encrypted traffic is sent between two
  endpoints.

* RPC-request: A request to perform an RPC action from a sender to a receiver.

* RPC-response: A response to an RPC-request sent from RPC-request
  receiver to the RPC-request sender.

<!--
sender: An endpoint which is sending a message from to another session over a link.

sender: An endpoint which is receiving a message from another session over a link.

datagram: A message that encapsulates protocol-specific traffic (e.g., an ICN
interest or content object).
-->


ICN-LLC Concepts
================

Assumptions
-----------
The ICN-LLC protocol makes the following assumptions:

(1) The communication parameters necessary to communicate over a link are
established before the protocol is executed. This includes settings
that, for example, enable bidirectional firewall traversal.

(2) The underlying link protocol provides the most basic ability to
frame/encapsulate and move an arbitrary (up to some maximum) sized
payload from one endpoint to another. We don't assume ordered or
reliable datagram transfer.

(3) Each endpoint has a cryptographic identity and can prove its
identity to the other endpoints over the respective links.

(4) To this end, endpoints are pre-configured with one or more trust
anchors permitting them to identity other endpoints that they trust
i.e., those endpoints that are allowed to participate in the execution
of the ICN-LLC protocol. These identities could be ascertained online
(making us of the trust anchors) or be pre-configured manually by
system administrators.

Cast
----

~~~
    ^    +------+ +-----+                       +-----+ +------+
 clients | CCNx | | NDN |                       | NDN | | CCNx |
    v    +------+ +-----+                       +-----+ +------+
             ^       |                             ^        ^
             |       |                             |        |
             v       v                             |        v
         +------API-----+ +- Session ---------+ +-----API------+
         | ICN-LLC      | | <-- LLC (RPC) --> | | ICN-LLC      |
         |              | | <----- CCNx ----> | |              |
         | session      | | ------ NDN -----> | | session      |
         | manager      | |   ...             | | manager      |
         +--------------+ +-------------------+ +--------------+

         <-- endpoint --> <------- link ------> <-- endpoint -->
~~~
{: #llc-cast title="Entities in ICN-LLC after secure association: all
logical links of the session are encrypted and authenticated."}



API for Endpoint Clients
------------------------

The goal of the ICN-LLC protocol and its session manager is to expose
an API that enables a run-time environment to connect local ICN
software (clients, like for example a CCNx forwarder) to a remote peer
by reusing the ICN-LLC's secured link.

This client API provides access to very basic services to interconnect
ICN peers. In a UNIX environment, the API could be structured as
follows (in C syntax):

~~~
     int icnllc_init(linkaddr *local, credentials *me, fct *notify);
     int icnllc_register(int icnllcHandler, protoID *pid, fct *upcall);
     int icnllc_deregister(int registerNr);
     int icnllc_openSession(int handler, linkaddr *peer, trustanchors *t);
     int icnllc_openPipe(int sessionHandler, protoID *pid, fct *notify);
     int icnllc_write(int pipeHandler, char *msg, int len);
     int icnllc_read(int pipeHandler, char *buf, int nbyte);
     int icnllc_closePipe(int pipeHandler);
     int icnllc_closeSession(int sessionHandler)
     int icnllc_fini(int icnllcHandler);
~~~

Wherever possible, ICN-LLC makes use of names rather than numbers to
identify parameters and entities. For example, protocol identifiers
are drawn from a string-based name space (the string IS the
identifier):

~~~
   typedef char* protoID;
   #define PROTOID_CCNX07  "/proto/icn/ccnx.2009"
   #define PROTOID_CCNX10  "/proto/icn/ccnx.2015"
   #define PROTOID_NDN     "/proto/icn/ndn.2013"
~~~


Client work flow
----------------

ICN clients e.g., forwarders, will use the API as follows.
A CCNx router wanting to establish a secure link to a peer would be
programmed as follows:

~~~
   llc = icnllc_init(&myUDP, &myCredentials);
   s = icnllc_openSession(llc, &remoteUDP, &myTrustAnchor);

   peer = icnllc_openPipe(s, "/proto/icn/ccnx.2015", NULL);
   // ... encrypted and authenticated write and read:
   // icnllc_write(peer, data, datalen);
   // icnllc_read(peer, &buf, sizeof*buf);

   // parallel pipe for client-level remote mgmt actions (also secured):
   peerMgmt = icnllc_openPipe(s, "/proto/icn/ccnx.2015.mgmt");
   // ...
   icnllc_closePipe(peerMgmt);

   icnllc_closePipe(peer);
   icnllc_closeSession(s)
   icnllc_fini(llc);
~~~

A NDN router
waiting for session establishment from other peers would issue this
sequence of actions (without showing error handling):

~~~
   llc = icnllc_init(&myUDP, &myCredentials);
   ndn = icnllc_register(llc, "/proto/icn/ndn.2013", NDNupcall);
   // ... serve pipe establishment in NDNupcall()
   icnllc_deregister(ndn);
   icnllc_fini(llc);
~~~



Link-level RPC and Logical Link Traffic
=======================================

All configuration state of a session, including state related to the
session's pipes, are managed by remote procedure operations. To this
end, two message types "RPC-request" and "RPC-response" are needed. A
third message type serves to recognize actual production (=
non-control) traffic, called "logical link traffic".

In the subsequent sections we describe these three message types and
their fields, as well as the INC-LLC protocol, in an encoding-neutral
way using prefixed lists. For example, a packet with the fields

~~~
  +----------------------------+
  | f1 | f2 | more fields here |
  +----------------------------+
~~~

will be represented as

~~~
  f1(f2, more fields here)
~~~

That is, a parethesis pair is used as a notation for a list. The empty
list is either shown as () or NIL.

We first show the data structures corresponding to the three message types
before explaining each of them.

~~~
  rpc-request (RID, verb, parameter-list)
  rpc-response(RID, OK|FAIL, result-list|reason-list)
  llt-message (LID, blob)

  RID = (SID, nonce)         # request ID
  LID = (SID, PID)           # logical link ID
  SID = (intval1, intval2)   # session ID
  PID = (intval1, intval2)   # pipe ID
~~~
{: #llc-msgs title="The three message types of ICN-LLC."}

RPC-request
-----------

(See also Figure [#llc-msgs]) An RPC-request message carries an ID
that identifyies the request instance (RID) as well as a verb (= name
of the remote procedure) and an optional payload with the list of
parameters.

The RID carries two pieces of information: The current session's ID
(SID) comes first, followed by a nonce. The role of the SID is to
refer to previously established state and must be kept constant for
all messages sent inside the established session. The Nonce is
randomly chosen for each new RPC-request and permits to retransmit a
request in case the sender thinks that the request or the reply got
lost. It is not a sequence number, though.


RPC-response
------------

An RPC-response is always the reaction to a received RPC-request. It
contains a copy of the request's RID so that the requestor can
correlate the answer with the pending request. Furthermore, the
RPC-response has a verb similar to the RPC-request. However, the
permitted verbs are limited to either "OK" or "FAIL".


Logical Link Traffic
--------------------

Logical Link Traffic refers to the messages that travel inside a
logical link (called pipe). This message type has two fields:
logical link ID and payload.

The logical link is identified by a tuple that refers to the session
context (SID) as well as the pipe to which this message belongs
to. In fact, the (SID, PID) tuple is a "network pointer" into the
other end's function space [NetPtrs]. The pipe ID is also a tuple,
in this case of two numbers. Often, pipes are used in pairs (for
bidirectional interconnection of ICN clients) in which case the
tuple's values are swapped.


Negotiation Tasks
=================

We now describe the major negotiation tasks (RPC calls) that make up
the LLC protocol.

{XXX.cft: say something about the negotiation style: select/set
instead of haggle}

{XXX.cft: say something about the required RPC failure semantics
(at-least-once vs at-most-once)}

Any side can initiate a remote procedure call at any time. It is
suggested to limit the number of RPCs that one side issues in parallel
to four (including nesting). For simplicity, we refer to each of the
endpoints in the protocol as Q for Questioner and R for Responder.


Session Initialization
----------------------

The session initialization task is the first step in establishing and
using a link between two endpoints. Assuming such a communication link
for the underlying transport protocol is established, it is done by
the following RPC exchange.

~~~
Q-->R: rpc-request((SID-1,0), nonce), START-SESSION, ())

On success:
  Q<--R: rpc-response((SID-1,0), nonce), OK, list(SID-2))
On failure:
  Q<--R: rpc-response((SID-1,0), nonce), FAIL, list(<reason>))
~~~
{: #session-init title="Session Initialization Message Exchange."}

After that exchange was executed, both ends will use the session ID
consisting of SID-1 and SID-2 i.e., (SID-1, SID-2) in order to refer
to this new session. In the following we abbreviate this tuple to SID.

Note that session initialization leaves the two endpoints in an
unsecure state until they have executed the secure association task
(see below).

{Question: how to handle/mitigate an attacker injecting
such "reset" messages?}
{CAW: each side could store a hash preimage that is revealed
during the SA step, but this induces state. If these two operations
are separated, then some state is necessary.}

Inspection (Get MTU)
--------------------

Inspection messages may be used to recover generic information
from an endpoint, e.g., the preferred MTU size. The RPC exchange
for an inspection message is as follows.

~~~
Q-->R: rpc-request(SID, nonce), LOOKUP, ("/conf/preferredMTU"))

On success:
  Q<--R: rpc-response((SID, nonce), OK, (<MTU value>))
On failure:
  Q<--R: rpc-response((SID, nonce), FAIL, (<reason>))
~~~
{: #inspection-msg title="Remote inspection (for MTU)."}

Inspection messages may be used to query any well-named object from
the recipient endpoint. In the example above, the inspection for the
preferred MTU would usually occur before establishing a secure session
association (SA).  Thus, before SA, the contents of the RPC request
and response are unencrypted.  However, after a SA is established, all
inspection messages will be encrypted like other link traffic.

Secure Association Establishment
--------------------------------

The secure association (SA) establishment message exchange is used to
create a secure session over a given link. This enables all subsequent
traffic, including RPC exchanges, to be authenticated and
encrypted. The goal is for each endpoint to authenticate the entity
running on the other endpoint of a given link, and to then establish
shared symmetric keys to perform authenticated encryption of all
traffic that follows the exchange.  Currently, we specify a simple
challenge-response mutual authentication protocol.  This can be
replaced with any functionally equivalent protocol.

Note that the SA involves nested RPCs: The responder to the initial
RPC request will do an RPC in reverse direction in order to
authenticate the requestor.

Note also that Encrypt(K,M) stands for the ciphertext resulting from
applying key K to message M and Signature(K,M) for a signature of M
using key KL.

~~~
Q-->R: rpc-request((SID, nonceA), “prove-identity",
                   (NIL, <optionsA>, <keyshareA>,
                    NIL, <challengeA-1, challengeA-2>))

Q<--R: rpc-request((SID, nonceB), “prove-identity"
                   (nonceA, <optionsB>, <keyshareB>,
                    NIL, <challengeB-1, challengeB-2>))

Q-->R: rpc-response((SID, nonceB), OK,
                    (Signature(key-Q, challengeB-1),
                     Encrypt(keyAB, (PIDa, challengeB-2, nonceB)))

Q<--R: rpc-response((SID, nonceA), OK,
                    (Signature(key-R, challengeA-1),
                     Encrypt(keyAB, (PIDb, challengeA-2, nonceA)))
~~~
{: #sa-init title="Secure Association with two challenge-response rounds."}

In the first message, the value NIL is used to represent an empty nonce.

The fields named optionsA and optionsB are key-value data structures
that contain the following information, at a minimum:

* Preferred identity information (e.g., the form of signature algorithm to use
    when processing the challenge and response).
* Diffie Hellman group parameters

The key key-{Q,R} is a private key of {Q,R} or a symmetric key
shared between Q and R.

Lastly, keyAB is the key material derived from the output of the
Diffie Hellman exchange with the shares keyshareA and keyshareB. That
is, logically,

    keyAB = DH(keyshareA, keyshareB)

When a failure occurs in the secure association RPC (not shown in the
diagram above), the recipient replies with an error code (in clear) as
in the Inspection message case and does not establish a new (or
replace an old) secured logical link.

Otherwise the secure association request succeeded and from this point
in time on the two endpoints will exchange their control messages in
encrypted form inside pipes.

To this end, the protocol above exchanged and authenticated two
endpoint-chosen numbers PIDa and PIDb. The pipe starting from the
side that chose the PIDa value, will use pipe ID PIDAB = (PIDa,
PIDb) while the other side can use pipe identifier PIDBA =
(PIDb,PIDa) to reply.  Subsequently we will refer to the respective
logical link identifiers that result from this as LIDAB=(SID,PIDAB)
and LIDBA=(SID,PIDBA)

For example, the remote inspection RPC can now be executed in a secured
fashion as follows:

~~~
Q-->R: llt-message(LIDAB, Encrypt(keyAB,
                   rpc-request((SID, nonce),
                               “lookup", ("/conf/preferredMTU"))))
On success:
Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                   rpc-response((SID, nonce),
                                OK, (<MTU value>))))
~~~
{: #secure-inspection title="RPC inside a local pipe."}


Set MTU
-------

Setting the MTU is a standard message in the LLC protocol that has
the following RPC exchange format.

~~~
Q-->R: llt-message(LIDAB, Encrypt(keyAB,
                   rpc-request((SID, nonce), "set", ("/conf/MTU", <value>))))

On success:
  Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                     rpc-response((SID, nonce), OK, (<value>))))
On failure:
  Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                     rpc-response((SID, nonce), FAIL, (<reason>))))
~~~
{: #set-mtu-msg title="Set the MTU."}


Create Logical Link (= pipe)
----------------------------

After a session and SA have been established, the protocol-specific
links (pipe) must be created. This is done with the following
exchange. The number 5 shown below is arbitrary and signals for this
specific task that Q or R can choose their part of the pipe ID at
will.

~~~
Q-->R: llt-message(LIDAB, Encrypt(keyAB,
                   rpc-request((SID, nonce), “create-pipe",
                   (PID-5a, Key-5QR, <icn-protocol-identifier>))))
On success:
  Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                     rpc-response((SID, nonce), OK, (PID-5b)))
On failure:
  Q<--R: llt-message(LIDBA, Encrypt(keyAB,
                     rpc-response((SID, nonce), FAIL, (<reason>))))
~~~
{: #pipe-create title="Logical Link (Pipe) Creation."}

This creates a new pipe whose identifier is the tuple (PID-5a,
PID-5b).  That is, for messages send through this pipe, questioner Q
will use the logical link ID LID5Q = (SID, (PID-5a, PID-5b)), whereas
the responder R will use LID5R = (SID, (PID-5b, PID-5a)).

Note that the messages will be encrypted by the symmetric key Key-5QR
that was unilaterally chosen by the initiator of this RPC.
Since each pipe is owned and controlled by the session manager, it
is sufficient for the session manager to simply derive and impose a new
encryption key Key-5QR for the pipe during creation. In other words,
it is not necessary to perform another multi-round Diffie Hellman key
exchange.

The pipe creation needs a remote target, expressed in form of an
client identifier "icn-protocol-identifier". If the new pipe cannot
be bound to such a client, the RPC may fail. A partial list of failure
reasons:

* "Protocol not supported"
* "Invalid key size"

Currently, each pipe will use the same encryption algorithm and parameters
for their respective traffic. This could be changed by allowing endpoints
to negotiate these parameters during the pipe creation exchange.


Destroy Logical Link (= pipe)
-------------------------------

Finally, when a pipe is finished, it must be destroyed and all state
must be recycled. This is done with the following exchange.

~~~
Q-->R: llt-message(LIDAB, encrypt(KeyAB,
                   rpc-request((SID, nonce), “destroy-pipe", (PID-5)))

Q<--R: llt-message(LIDBA, encrypt(Key-AB,
                   rpc-response((SID, nonce), OK, NIL)))
~~~
{: #pipe-destroy title="Logical Link (Pipe) Destruction."}

After this exchange, both parties tear down and recycle their local
state. That is, both pipes (PID-5a,PID-5b) and (PID-5b,PID-5a) will
be destroyed at the same time. This destroy action request is
idempotent; attempting to destroy a non-existent pipe will yield an
OK response from the recipient.

Note that the two pipes representing the logical control link, named
(SID, PIDBA) and (SID, PIDAB) above, cannot be close. Instead, the
"destroy-session" RPC must be used.

<!-- //// I stopped editing here (cft) -->


Keep-Alive
----------

Use the NOOP call to verify that the peer session manager is still up
and running.

~~~
Q-->R: llt-message(LIDAB, encrypt(KeyAB,
                   rpc-request((SID, nonce), NOOP, NIL)))

Q<--R: llt-message(LIDBA, encrypt(Key-AB,
                   rpc-response((SID, nonce), OK, NIL)))
~~~


Encoding of Non-control Traffic and RPC Parameters
==================================================

Structurally, all three message types of ICN-LLC are identical in
being a list of fields. A single header byte discriminates among the
message types, followed by an encoding of the message's field list:

~~~
     Byte 0    Bytes 1 to N-1
  +---------+--------------//--+
  | msgtype | listEncoding ....|
  +---------+--------------//--+
~~~

Encoding of message type
------------------------

The assigned values for the one-byte-header are:

~~~
  0x81  llt-message
  0x82  rpc-request
  0x83  rpc-response
~~~


Encoding of a message's fields (list encoding)
-------------------------------------------

ICN-LLC encodes lists in a similar way as was proposed by Rivest for
symbolic expressions [SEXPR]. The variation consists in combining the
"list bit" with a variable length field and in omitting the 0x00
byte to signal the end-of-list (because the length field already
encodes this information).

In ICN-LLC, a data structure is represented as a two-tuple of
type+length and the content bytes: (TL, value). The length tells the
amount of bytes needed to represent the value.

A data structure either is a list or an atom. The general format for a list is:

~~~
  <list-bit=1, len-in-bytes> <element-1> ... <element-N>
~~~

where an element can be either another list or an atom.

The format for an atom is:

~~~
  <list-bit=0, len-in-bytes> <blob>
~~~

Two atom types are defined (but the type is not made explicit in the
ICN-LLC encoding): Strings are encoded without trailing zero, integer
values are signed and are encoded in network order format.

The type+len information is encoded with a varying number of bytes
depending on the value of len. In the following diagram, "L" stands
for the list-bit and "l" for a bit of the length value to be encoded
(unsigned, network order).

~~~
  len value      encoding (bits)

  0 .. 63        L0ll llll
  64 .. 8191     L10l llll  llll llll
  8192..1048575  L110 llll  llll llll  llll llll
  reserved       L111 ...
~~~


Length of Identifier Fields
---------------------------

Although fields can vary in length and therefore, for example, a
pipeID could consist of two 8-bit values, it is recommended to
implement identifiers according to the following MINIMAL lengths:

~~~
  4 Bytes    nonce
  2x2 Bytes  session ID
  2x2 Bytes  pipe ID
~~~


Encoding Examples
-----------------

a) LLT message 

~~~
  llt-message(((0x1234,0x5678)(0x1111,0x2222))"abc") --> 21 Bytes
 
  0x81                     % msg type
  0x93                     % 0x80 + total length
    0x8e                   % LID
      0x86                 % SID
        0x02 0x12 0x34
        0x02 0x56 0x78
      0x86                 % PID
        0x02 0x11 0x11
        0x02 0x11 0x11
    0x03 0x61 0x62 0x63    % payload
~~~

b) RPC-request (start session)

~~~
  rpc-request(((0x1234,0)0x73683559)"_rst"()) --> 19 Bytes

  0x82                     % msg type
  0x91                     % 0x80 + total length
    0x8a                   % RID
      0x84                 % SID
        0x02 0x12 0x34
        0x00
      0x04                 % nonce
        0x73 0x68 0x35 0x59
    0x04                   % verb
      0x5f 0x72 0x73 0x74
    0x80                   % empty param list
~~~

c) RPC-response (session ack)

~~~
  rpc-response(((0x1234,0x5678)0x73683559)0x00()) --> 17 Bytes

  0x83                     % msg type
  0x8f                     % 0x80 + total length
    0x8c                   % RID
      0x84                 % SID
        0x02 0x12 0x34
        0x02 0x56 0x78
      0x04                 % nonce
        0x73 0x68 0x35 0x59
    0x01 0x00              % OK
    0x80                   % empty param list
~~~



Minimum MTU, Fragmentation of LLC Messages and Message Stuffing
---------------------------------------------------------------

None of the three message types (LLT-message, RPC-request,
RPC-response) may be fragmented.

However, using RPC and being subject to negotiation, peers might use
RPC to transfer parts of a larger message for remote assembly and then
trigger the delivery of that remote memory block.

The minimum (link-level) MTU is 1280 bytes (OK?). This permits ...

Multiple LLC messages can be combined into one frame as long as they
fully fit into the link's MTU.

Security Considerations
=======================

yes

References
==========


* S-expressions   http://people.csail.mit.edu/rivest/Sexp.txt
* Network pointers http://conferences.sigcomm.org/hotnets/2002/papers/tschudin.ps


RPC Verbs and Configuration Name Space
======================================

Verbs:

~~~
  OK               byte 0x00
  FAIL             byte 0x01
  START-SESSION    "_rst"    , or "HELO" ....
  END-SESSION      "_fin"
  LOOKUP           "_get"
  CONFIGURE        "_set"
  NOOP             "_nop"
  PROVE-IDENTITY
  PIPE-CREATE
  PIPE-DESTROY
~~~

Constants and "state registers" (MIB):

~~~
  /proto/icn/....
  
  /conf/rw/icnllc-version
  /conf/ro/preferredMTU
  /conf/rw/MTU
~~~

--- back

